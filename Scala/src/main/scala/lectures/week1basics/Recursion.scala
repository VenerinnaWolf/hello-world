package lectures.week1basics

import scala.annotation.tailrec  // для аннотаций хвостовых рекурсивных функций

// Рекурсия это рекурсия (и немного про циклы)

@main def Recursion(): Unit = {

  // ------- Цикл while -------

  // Выведем слово "Hello" n раз:
  val n = 3
  var i = 0
  while (i < n) {
    println("hello")
    i += 1
  }
  // * Кстати, while всегда возвращает тип Unit, вне зависимости от того, что в нем описано

  // Циклы не приветствуются в функциональном программировании, т.к они базируются на var переменных,
  // var переменная небезопасна, т.к мы не можем гарантировать, что она не была изменена.
  // Предпочтительно использовать не var переменные, а val, но в цикле так не получится.

  // Поэтому для подобного лучше использовать рекурсию:

  // ------- Рекурсия -------

  def factorial(n: Int): Int = {
    if (n <= 0) 1
    else n * factorial(n - 1)
  }

  println(factorial(3)) // выводит 6

  // Каждый шаг рекурсии хранится в стеке, у которого есть ограничения по памяти.
  // Чтобы не было ошибок типа StackOverflow при больших числах, нужно использовать хвостовую рекурсию:


  // ------- Хвостовая рекурсия -------

  // 1. Функция является функцией с хвостовой рекурсией, только если последний исполняемый оператор этой функции:
  // а) либо возвращает значение
  // б) либо является вызовом этой же функции (без всяких дополнительных операций!)
  // Та рекурсия, которая у нас была не удовлетворяет требованию б:
  def notTailRecursion(n: Int): Int = {
    if (n <= 0) 1   // возвращает 1, тут все нормально, пункт "а" выполнен
    else n * notTailRecursion(n - 1)  // вызывает саму себя И умножает результат на n, пункт "б" не выполнен
  }
  notTailRecursion(10)

  // 2. Перепишем ее под хвостовую рекурсию.
  // Добавим еще один параметр - accumulator - промежуточный результат каждой итерации функции
  def tailRecursion(n: Int, accumulator: Int = 1): Int = {
    if (n <= 0) accumulator   // возвращает значение accumulator, пункт "а" выполнен
    else tailRecursion(n - 1, n * accumulator)  // вызывает саму себя, пункт "б" выполнен
  }
  tailRecursion(10, 1)

  // 3. Обычно хвостовую рекурсию оборачивают в другую функцию, которая уже будет вызываться:
  def factorialWithTailRecursion(n: Int): BigInt = {
    def loop(x: Int, accumulator: BigInt = 1): BigInt = {  // частое имя для хвостовой рекурсии: loop или go
      if (x <= 1) accumulator
      else loop(x - 1, x * accumulator)
    }

    loop(n, 1)
  }

  factorialWithTailRecursion(10)

  // *В хвостовой рекурсии при компиляции стек превращается в цикл, что убирает возможность переполнения стека.

  // 4. Аннотация @tailrec
  // Перед хвостовой рекурсией можно добавить аннотацию, которая говорит другим разработчикам и компилятору,
  // что тут хвостовая рекурсия. Если функция окажется не хвостовой, код не скомпилируется.
  // Главное не забыть прописать в начале файла: import scala.annotation.tailrec

  // 5. Перепишем код из цикла в начале в виде хвостовой рекурсии:
  //  val n = 3
  //  var i = 0
  //  while (i < n) {
  //    println("hello")
  //    i += 1
  //  }

  // Вот такое решение предлагается в курсе:
  def repeatWord(word: String, n: Int): String = {
    @tailrec
    def loop(i: Int, acc: String = word): String = {
      if (i <= 1) acc
      else loop(i - 1, s"$word $acc")
    }

    loop(n)
  }
  println(repeatWord("hello", 3))

  // Мне оно не очень понравилось, и вот почему:

  // Данное решение не совсем точно повторяет изначальный цикл.
  // В цикле мы n раз вызывали print("hello").
  // Здесь же мы в рекурсии создаем строку, состоящую из n "hello" и уже вызываем один раз print("hello hello hello").
  // Это немного не одно и то же.

  // Если в точности повторять цикл, то решение будет выглядеть примерно так:
  def repeatWord1(word: String, n: Int): String = {
    @tailrec
    def loop(i: Int, acc: String = word): String = {
      print(acc)
      if (i <= 1) acc
      else loop(i - 1, acc)
    }

    loop(n)
  }
  repeatWord1("hello", 3)

  // Но я не уверена, насколько это соответствует идее хвостовой функции:
  // по сути аккумулятор ничего не накапливает и возвращаемое значение функции нам тоже не нужно.

  // То есть можно переписать вообще вот так:
  def repeatWord2(word: String, n: Int): Unit = {
    @tailrec
    def loop(i: Int, acc: String = word): Unit = {
      print(acc)
      if (i > 1) loop(i - 1, acc)
    }

    loop(n)
  }
  repeatWord2("hello", 3)

  // А подумав еще немного я пришла вот к такому выводу:
  // зачем мы вообще оборачиваем функцию в другую функцию, если ничего нового она не делает?

  // Почему тогда не написать просто:
  @tailrec
  def repeatWord3(word: String, n: Int): Unit = {
    print(word)
    if (n > 1) repeatWord3(word, n - 1)
  }
  repeatWord3("hello", 3)
}
