<!-- Если openserver не работает, почитай вот тут https://delphinpro.ru/a/7 -->
<!-- Мануал писался вот по этому гайду - https://www.programulin.ru/ -->

<?php echo "Hello, <strong>php</strong> world!" ?>

<?php 
    # Короткий комментарий
    // Еще один
?>

<!-- Короткий тег заменяющий <?php echo ''; ?> -->
<?= '<p>Короткий тег заменяющий &lt;?php echo ?&gt' ?>

<?php
    /*
    Это многострочный комментарий в php
    Информация с текущими настройками PHP.
    */
    phpinfo();
?>

<!--            ----------            -->
<!--            Переменные            -->
<!--            ----------            -->

    <!-- Создание переменной -->
    <?php
        $mail = 'test@mail.ru'; 
    ?>

    <!-- Использование переменной через html (лучше код php не разбивать кодом html) -->
    <p>Это мой адрес почты: <?= $mail ?></p>

    <!-- Передача нескольких значений в echo -->
    <?php
        $name = 'Вероника';
        echo '<p>Меня зовут ', $name, ", приятно познакомиться<p>"; 
        // Проверка содержимого переменной - показывает тип переменной, длину  и содержимое
        var_dump('Vasya'); // string(5) "Vasya"
        var_dump(''); // string(0) ""
        var_dump(5); // int(5) 
        // Удаление переменной
        unset($name);    
    ?>

<?php 
?>

<!--            ------------------------            -->
<!--            Арифметические операторы            -->
<!--            ------------------------            -->

<?php
    echo 5 + 5, '<br>'; // сложение
    echo 4 - 2, '<br>'; // вычитание
    echo 2 * 2, '<br>'; // умножение
    echo 4 / 2, '<br>'; // деление
    echo 5 % 2, '<br>'; // остаток от деления

    // Результат вычислений можно записать в переменную
    $var = 5 + 5;
    echo $var;
?>

<!--            -----------            -->
<!--            Типы данных            -->
<!--            -----------            -->

<?php
    // ------
    // Строки
    // ------

        $name =  'Петя';
        echo 'Привет, $name'; // Привет, $name
        echo "Привет, $name"; // Привет, Петя

    // -------
    // Булевые
    // -------

        $is_show = true;
        $can_move = false;

    // -----------
    // Целое число
    // -----------

        $sale = -800; 
        /* Размер от -2 147 483 648 до 2 147 483 647, т.е. ± 2 миллиарда для 32-битных версий PHP
        или от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807, т.е. ± 9 квинтиллионов для 64-битных версий PHP */
        
        // Помимо десятичной системы счисления, PHP также поддерживает двоичную, восьмеричную и шестнадцатеричную:
        $num = 1234; // десятичное число
        $num = 0123; // восьмеричное число (эквивалентно 83 в десятичной системе)
        $num = 0x1A; // шестнадцатеричное число (эквивалентно 26 в десятичной системе)
        $num = 0b11111111; // двоичное число (эквивалентно 255 в десятичной системе)

    // -------------
    // Дробное число
    // -------------

        $num = 15.28;
        
        // Для проверки точности чисел с плавающей запятой НЕЛЬЗЯ использовать простой оператор сравнения
        $num1 = 0.1 + 0.2;
        var_dump($num1 == 0.3); // Будет false
        
        // Нужно использовать функции произвольной точности
        $num2 = bcadd(0.1, 0.2, 1); // Сложение двух числе, 1 - число знаков после запятой
        var_dump($num2 == 0.3); // Будет true

    // ------
    // Массив
    // ------

        $array = [
            'name' => 'Вася',
            'age' => 18
        ];
        echo $array['name']; // Вася

    // ------
    // Объект
    // ------

        class User {
            public $name;
            public $age;

            public function show()
            {
                echo $this->name, ' ', $this->age;
            }
        }

        $petya = new User;
        $petya->name = 'Вася';
        $petya->age = 18;
        $petya->show(); // Вася 18

    // ------
    // Ресурс - ссылка на внешний ресурс
    // ------
        $resource = fopen('D:\OpenServer\domains\test.local\file.txt', 'r'); // функция fopen возвращает ссылку на файл

    // ----
    // NULL - отсутствие значения
    // ----
        $var = null;

    // -------------------------
    // Получение типа переменной
    // -------------------------

        echo gettype(15); // integer
        echo gettype('Вилка'); // string
        echo gettype(true); // boolean
?>

<!--            -----------------------------------------            -->
<!--            Динамическая типизация и приведение типов            -->
<!--            -----------------------------------------            -->

<?php
    // ------
    // Пример
    // ------

        echo 2 * '11abc DEF 150'; // 22  !!!
        var_dump(1 == '1abc'); // bool(true)  !!!
        
        $a = 10; // 10 - integer (целое число)
        $a = $a * 1.1; // При умножении целого числа на дробное результат - дробное число 
        echo gettype($a); // double, т.е. дробное число

    // ----------------
    // Приведение типов
    // ----------------

        $var = 5;
        $var = (string) $var; // Теперь в переменной лежит строка '5'
        $var = (int) $var; // Теперь опять целое число
        $var = (float) $var; // Теперь дробь 5
        $var = (bool) $var; // Теперь true

    // -----------------------------------
    // Арифметические операции со строками - число будет получено из первых числовых символов
    // -----------------------------------

        echo '12abc1' + 2; // 12 + 4 = 14

        // ------------------------
        // Приведение к булеву типу
        // ------------------------

        /*  false - это:
            0 (целое или дробное)
            '' (пустая строка)
            '0' (строка с числом 0)
            [] (пустой массив)
            null

            true - все остальное
        */
?>

<!--            ----------------------------------------------------            -->
<!--            Кавычки, экранирование символов и прочие спецсимволы            -->
<!--            ----------------------------------------------------            -->

<?php
    // В двойные кавычки можно подставить значение другой переменной, в одинарные нельзя
    $name = 'Вася';
    echo 'Меня зовут $name'; // Меня зовут $name
    echo "Меня зовут $name"; // Меня зовут Вася

    $price = 1499;
    echo "$priceруб"; //Ошибка Undefined variable
    echo "{$price}руб"; // 1499руб

    
    // ---------------------
    // Экранирование кавычек    
    // ---------------------

    echo 'Прачечная "Судный день" работает с 9:00'; // Просто одни кавычки внутри других
    echo "Прачечная 'Судный день' работает с 9:00";

    echo 'Прачечная \'Судный день\' работает с 9:00'; // Экранирование обратным слешем
    echo "Прачечная \"Судный день\" работает с 9:00";
    echo '\\'; // Выведет только один обратный слеш
    
    // --------------------------
    // Табуляция и перенос строки
    // --------------------------
    
    $var1 = "Перенос строки: \n";
    $var2 = "Табуляция: \t";
?>

<!--            ---------            -->
<!--            Константы            -->
<!--            ---------            -->

<?php
    // ------------------
    // Создание константы
    // ------------------
    
        // Есть два способа создания константы - через const и через define(). Перед константой знака $ нет
        const LOGIN = 'admin';
        define('PASSWORD', 'qwerty');
        // Cуществует общепринятое соглашение всегда писать константы большими буквами, а слова разделять нижним подчёркиванием, например MY_SUPER_CONSTANT

        echo LOGIN, ' ', PASSWORD;

    // ------------------------------
    // Значение константы по ее имени
    // ------------------------------
        
        // С помощью функции constant() мы можем получить значение константы, имя которой лежит в переменной:
        $const_name = 'LOGIN';
        echo constant($const_name); // admin

    // ----------------------------
    // Существующие константы в PHP
    // ----------------------------

        // Встроенные константы - различные уровни ошибок: E_ERROR, E_WARNING, E_NOTICE и т.д.
        
        // Магические константы - значения, меняющиеся в зависимости от контекста:
        /*
            __LINE__ - текущая строка в скрипте
            __FILE__ - полный путь и имя текущего скрипта
            __DIR__ - полный путь к директории, в которой расположен скрипт
            __FUNCTION__ - имя текущей функции
            __CLASS__ - полный путь и имя текущего скрипта
            __TRAIT__ - имя текущего трейта с пространством имён
            __METHOD__ - имя текущего метода
            __NAMESPACE__ - имя текущего пространства имён
            ClassName::class - имя класса, к которому мы обращаемся, с пространством имён
        */

?>

<!--            ------------------------------------------------------------------------------            -->
<!--            Оператор присваивания, инкремент, декремент, конкатенация, операторы сравнения            -->
<!--            ------------------------------------------------------------------------------            -->

<?php
    // ---------------------
    // Оператор присваивания
    // ---------------------

        $x = 5;
        $x += 2; // То же, что $x = $x + 2;
        $x -= 2; // То же, что $x = $x - 2;
        $x *= 2; // То же, что $x = $x * 2;
        $a = $b = $c = 15; // Множественное присваивание значений

    // --------------
    // Ин(де)кременты
    // --------------

        ++$x; // (пре-инкремент) - сначала увеличивает значение, затем возвращает его.
        $x++; // (пост-инкремент) - сначала возвращает значение, затем увеличивает его.
        --$x; // (пре-декремент) - сначала уменьшает значение, затем возвращает его.
        $x--; // (пост-декремент) - сначала возвращает значение, затем уменьшает его.

    // ------------------
    // Конкатенация строк - пишется через точку
    // ------------------

        $price = 1500;
        $currency = ' руб';
        echo $price . $currency; // 1500 руб

        // Можно использовать с оператором присваивания
        $str = 'Это ';
        $str .= 'очень ';
        $str .= 'длинная ';
        $str .= 'строка.';
        echo $str; // Результат - 'Это очень длинная строка.' 

    // -------------------
    // Операторы сравнения
    // -------------------

        /*
            $a == $b	Истина, если $a равна $b после изменения типов.
            $a === $b	Истина, если $a равна $b и имеет тот же тип.
            $a != $b	Истина, если $a не равна $b после преобразования типов.
            $a <> $b	Истина, если $a не равна $b после преобразования типов.
            $a !== $b	Истина, если $a не равна $b или они разных типов.
            $a < $b	    Истина, если $a меньше $b.
            $a > $b	    Истина, если $a больше $b.
            $a <= $b	Истина, если $a меньше или равна $b.
            $a >= $b	Истина, если $a больше или равна $b.
            $a <=> $b	Возвращает -1, 0 или 1 когда $a соответственно меньше, равно или больше $b. Доступно с PHP 7.
        */
?>

<!--            Далее идет блок с различными --- условными операторами ---            -->

<!--            ----------------            -->
<!--            Оператор IF ELSE            -->
<!--            ----------------            -->

<?php
    // -------
    // IF ELSE
    // -------
        
        // Для одной команды
        if(100 > 50)
            echo 'Условие верно.<br>';
        else
            echo 'Условие неверно.<br>';

        // Для нескольких команд
        if(200 > 100)
        {
            echo 'Условие ';
            echo 'верно.';
        }
        else
        {
            echo 'Условие ';
            echo 'неверно.';
        }
        // Или вот так
        if(200 > 100) {
            echo 'Условие ';
            echo 'верно.';
        } else {
            echo 'Условие ';
            echo 'неверно.';
        }

    // ------------------
    // Конструкция ELSEIF
    // ------------------

        $price = 150;
        if($price < 50)
            $price *= 1.3; // Умножаем цену на 30%
        elseif($price < 100)
            $price *= 1.2; // Умножаем цену на 20%
        elseif($price < 200)
            $price *= 1.1; // Умножаем цену на 10%
        else
            $price *= 1.05; // Умножаем цену на 5%
?>

<!--            --------------------------------------            -->
<!--            Альтернативный синтаксис IF ELSE ENDIF            -->
<!--            --------------------------------------            -->

    <?php if($price > 100): ?>
        <div class="div1"></div>
        <div class="div2"></div>
    <?php elseif($price < 50): ?>
        <div class="div3"></div>
        <div class="div4"></div>
    <?php else: ?>
        <div class="div5"></div>
        <div class="div6"></div>
    <?php endif; ?>

    <!-- Для сравнения, тот же кусок кода в обычном синтаксисе: -->
    <?php if($price > 100) { ?>
        <div class="div1"></div>
        <div class="div2"></div>
    <?php } elseif($price < 50) { ?>
        <div class="div3"></div>
        <div class="div4"></div>
    <?php } else { ?>
        <div class="div5"></div>
        <div class="div6"></div>
    <?php } ?>

<?php 
?>

<!--            ------------------------            -->
<!--            Тернарный оператор в PHP            -->
<!--            ------------------------            -->

<?php 
    // Тернарный оператор является более коротким аналогом IF и в некоторых случаях позволяет значительно сократить код.
    
    $price = 100;

    // Код с оператором IF
    if($price < 1000)
        $shipping = 200;
    else
        $shipping = 100;

    // Аналогичный код с тернарным оператором
    $shipping = $price < 1000 ? 200 : 100; 

    // Условие можно взять в скобки, если так удобнее, но это необязательно
    $shipping = ($price < 1000) ? 200 : 100;

    // Также вместо обычных значений в тернарный оператор можно подставить вызов функций:
    $i = 0;
    $i === 0 ? print('Ноль') : phpinfo(); // одно из различий между echo и print заключается в том, что print можно подставить в тернарный оператор, а echo нельзя.
    
    // ----------------------------
    // Вложенный тернарный оператор
    // ----------------------------
        
        $price = 5000;

        // Обычный синтаксис
        if($price > 10000)
            $shipping = 0;
        elseif($price > 500)
            $shipping = 100;
        else
            $shipping = 200;

        // Сокращённый синтаксис (тернарный оператор)
        $shipping = $price > 10000 ? 0 : ($price > 500 ? 100 : 200); // Вложенный тернарный оператор обязательно помещается в скобки.
        // Вложенные тернарные операторы взрывают мозг, поэтому их лучше никогда не использовать.

    // ---------------------
    // Пропуск средней части
    // ---------------------

        // Также в тернарном операторе есть возможность пропуска средней части:
        $var = 5;
        echo $var ?: 10;
        /*  В этом случае тернарный оператор вернёт значение $var, если оно после приведения к булеву типу будет true. 
            А если будет false, то вернётся указанное справа значение. */
        
        // Еще один пример: 
        $price = 100;
        var_dump ($price ?: 10); // 100 потому что $price == true

        $price = 0;
        var_dump($price ?: 10); // 10 потому что $price == false
?>

<!--            --------------------------            -->
<!--            Логические операторы в PHP            -->
<!--            --------------------------            -->

<?php
    // -------------------------
    // Все логические операторы:
    // -------------------------

        /*  
            $a && $b
            Истина, если $a и $b равны true.
            $a || $b	Истина, если хотя бы одна из $a и $b равна true.
            $a xor $b	Истина, если одна из $a и $b равна true, но не обе.
            !$a	Истина, если $a не равна true.
            $a and $b	Аналогично &&
            $a or $b	Аналогично ||
        */

        // Между операторами && и and, а также между || и or есть небольшое различие - порядок выполнения:
        // операторы and и or имеют приоритет ниже, чем оператор присваивания =.
        $var = true && false;
        var_dump($var); // Выведет false

        $var = true and false; // для php этот код выглядит как ($var = true) and false;
        var_dump($var); // Выведет... true!

    // ---------------------
    // Приоритеты операторов. Чем выше оператор в таблице - тем выше его приоритет.
    // ---------------------

        /*
            ++ -- ~ (int) (float) (string) (array) (object) (bool) @
            * / %
            + - .
            < <= > >=
            == != === !== <> <=>
            &&
            ||
            ? : (тернарный оператор)
            = += -= *= **= /= .= %= &= |= ^= <<= >>=
            and
            xor
            or
        */
?>

<!--            ---------------            -->
<!--            Оператор SWITCH            -->
<!--            ---------------            -->

<?php
    $status = 2; // Номер статуса заказа

    if($status == 1)
        echo 'Статус: Обрабатывается';
    elseif($status == 2)
        echo 'Статус: Передан в доставку';
    elseif($status == 3)
        echo 'Статус: Выполнен';
    else
        echo 'Статус: Неизвестен';

    // Аналогичный код для switch
    switch($status)
    {
        case 1:
            echo 'Статус: Обрабатывается';
            break;
        case 2:
            echo 'Статус: Передан в доставку';
            break;
        case 3:
            echo 'Статус: Выполнен';
            break;
        default:
            echo 'Статус: Неизвестен';
    }

    // Конструкция switch использует нестрогое сравнение ==   !!!

    // Также в switch можно использовать один блок кода для нескольких значений т.к switch выполняет все команды подряд, даже если они находятся в разных блоках case:
    switch($status)
    {
        case 1:
        case 2:
            echo 'Ожидайте звонка менеджера';
            break;
        case 3:
        case 4:
            echo 'Заказ скоро будет доставлен';
    }    
?>

<!--            -------            -->
<!--            Массивы            -->
<!--            -------            -->

<?php
    // ----------------
    // Создание массива
    // ---------------- 

        $heroes = ['Шварценеггер', 'Сталлоне', 'Джеки Чан']; // Простой/числовой массив (ключи - индексы 0, 1, 2...)
        $arr = []; // Пустой массив
        // Ассоциативный массив: ключи - это не индексы 0, 1, 2.., а слова 'article', 'name' и 'price'
        $product = [
            'article' => 'ABC123',
            'name'    => 'Смартфон iPhone X 64Gb White',
            'price'   => 50000,
        ];
        // Одновременно в массиве могут быть как простые ключи (0, 1, 2...), так и слова

    // -------------
    // Вывод массива
    // -------------

        // Обращение к элементу массива
        echo $heroes[0]; // Выводим элемент с ключом 0

        // Для вывода массива можно использовать функцию var_dump() или print_r():
        var_dump(['samsung', 'apple', 'nokia']); // результат в браузере - array(3) { [0]=> string(7) "samsung" [1]=> string(5) "apple" [2]=> string(5) "nokia" } 
        print_r(['samsung', 'apple', 'nokia']); // результат в браузере - Array ( [0] => samsung [1] => apple [2] => nokia ) 
        // Чтобы не выводилось все в одну строку, можно использовать тег <pre>:
        echo '<pre>';
        print_r(['val1', 'val2', 'val3']);
        echo '</pre>';

        // Можно вывести с помощью цикла foreach:
        $arr = ['Огонь', 'Вода', 'Воздух', 'Земля'];
        foreach($arr as $key => $value)
            echo $key . ':' . $value . '<br>';

    // --------------------
    // Добавление элементов
    // --------------------

        $arr = ['name' => 'Вася'];

        // Добавляем элементы
        $arr['age'] = 20;
        $arr['status'] = 'В смятении';

        // Перезаписываем элемент
        $arr['status'] = 'Спокоен';

        // Если название ключа не играет роли, его можно опустить:
        $var = [15, 20, 25];
        $var[] = 30; // Элемент добавится с ключом 3
        $var[] = 35; // Элемент добавится с ключом 4

    // ------------------
    // Удаление элементов
    // ------------------

        $arr = [1, 2, 3];
        unset($arr[0]); // Удаляем 1-ый (0-й) элемент

    // -------------------------------
    // Двумерные и многомерные массивы
    // -------------------------------

        $human = ['name' => 'Вася'];

        // Добавляем новый элемент, содержащий массив
        $human['hands'] = ['left', 'right'];

        // Обратиться к элементу многомерного массива можно так:
        echo $human['hands'][0]; // выведет 'left'
        
        // Еще один пример создания многомерного массива:
        $products = [
            [
                'name' => 'iPhone',
                'price' => 5000,
                'status' => true
            ],
            [
                'name' => 'Samsung Galaxy',
                'price' => 5000,
                'status' => true
            ]
        ];
        // Или альтернативный вариант:
        $products = [];

        $products[] = [
            'name' => 'iPhone',
            'price' => 5000,
            'status' => true
        ];

        $products[] = [
            'name' => 'Samsung Galaxy',
            'price' => 5000,
            'status' => true
        ];
        
    // ----------------------------
    // Количество элементов массива
    // ----------------------------

        echo count([5, 10, 15]); // выведет 3

        // Если вторым параметром передать встроенную в PHP константу COUNT_RECURSIVE, 
        // то мы получим количество элементов массива и всех подмассивов, которые в нём находятся:
        $arr = [1, 2, 3];
        $arr['childs'] = [4, 5, 6];

        echo count($arr, COUNT_RECURSIVE); // выведет 7

    // --------------------
    // Объединение массивов
    // --------------------

        // Объединить несколько массивов можно с помощью функции array_merge(), она может принимать неограниченное количество массивов:
        $nums1 = [5, 10, 15];
        $nums2 = [20, 25, 30];
        $nums3 = [35, 40, 45];
        // В $result будет массив из 9 элементов
        $result = array_merge($nums1, $nums2, $nums3);
        
        // Если массивы имеют одинаковые числовые ключи, то в результате сохранятся оба значения.
        // Но если в массивах будут одинаковые строковые ключи, то значение из следующего массива перезапишет предыдущее:
        $arr1 = [
            'name' => 'Себастьян',
            'age' => 25
        ];

        $arr2 = [
            'name' => 'Василий',
        ];

        print_r(array_merge($arr1, $arr2));
        /* Результат в браузере:
                Array
            (
                [name] => Василий
                [age] => 25
            )
        */

    // -----------------------
    // Преобразование массивов
    // -----------------------

        // Преобразование строки в массив
        // в функцию explode() нужно передать саму строку и символ, по которому она будет разбиваться:
        $str = 'Я крутой программист';
        $arr = explode(' ', $str);

        print_r($arr);
        /* Результат в браузере:
                Array
            (
                [0] => Я
                [1] => крутой
                [2] => программист
            )
        */

        // Преобразование массива в строку
        // в функцию implode() необходимо передать массив и символ, который будет вставляться между значениями:
        $arr = ['спагетти', 'чипсы', 'молоко'];
        $string = implode('|', $arr);

        var_dump($string);
        /* Результат в браузере:
            string(40) "спагетти|чипсы|молоко"  */
        
        // Если разделитель не нужен - можно передать null или пустую строку.
?>

<!--            Далее идет блок с различными --- циклами ---            -->

<!--            ------------            -->
<!--            Цикл FOREACH            -->
<!--            ------------            -->

<?php

    // Цикл FOREACH перебирает все элементы массива

    $arr = [5, 10, 15];

    foreach($arr as $value) { // т.е. для каждого(элемента массива $arr берем значение $value). $value - новая переменная
        echo $value; // что-нибудь делаем со значением $value, в данном случае выводим на экран
    }
    // Если команда одна, то скобки можно опустить

    // ---------------------------------- 
    // Получение доступа к ключам массива
    // ---------------------------------- 

        // Можно перебрать массив вместе с его ключами:
        $arr = [10, 15, 20];

        foreach($arr as $key => $value) // т.е. для каждого(элемента массива $arr с ключом $key => значением $value). $key и $value - новые переменные
            echo $key, ' ', $value, '<br>'; // делаем что-нибудь
        
    // ---------------------------- 
    // Перебор многомерного массива
    // ---------------------------- 

        // Создадим обычный двумерный массив:
        $arr['title1'] = [5, 10, 15];
        $arr['title2'] = [48, 12, 0];
        $arr['title3'] = [17, 24, 1280];

        // Перебор элементов только одного подмассива:
        foreach($arr['title3'] as $value)
            echo $value, '<br>';

        // Если требуется вывести все подмассивы, используем вложенные циклы
        foreach($arr as $title => $values)
        {
            echo 'Title: ', $title, '<br>';

            foreach($values as $value)
                echo 'Value: ', $value, '<br>';

            echo '<br>';
        }
        /* Результат в браузере:
            Title: title1
            Value: 5
            Value: 10
            Value: 15

            Title: title2
            Value: 48
            Value: 12
            Value: 0

            Title: title3
            Value: 17
            Value: 24
            Value: 1280
        */ 

    // ------------------
    // Еще обычный пример
    // ------------------

        $products[] = ['name' => 'Товар1', 'price' => 1000];
        $products[] = ['name' => 'Товар2', 'price' => 2000];
        $products[] = ['name' => 'Товар3', 'price' => 3000];

        foreach($products as $product)
        {
            if($product['price'] > 1000)
                echo $product['name'] . '<br>';
        }
?>

<!--            ----------            -->
<!--            Цикл WHILE            -->
<!--            ----------            -->

<?php
    // Цикл WHILE выполняется, пока выражение в скобках принимает значение true.
    $i = 0;

    while($i < 5)
        echo ++$i;
    /* Результат в браузере:  12345  */
    
    // -----------
    // Вечный цикл
    // -----------
    while(true) {}
    
    // -----------------------------------
    // Цикл WHILE с несколькими условиями:
    // -----------------------------------

    $a = 5;
    $b = 10;
    $c = 0;

    while($a < 10 && $b < 20 && $c < 10)
        echo ++$a;
?>

<!--            -----------------            -->
<!--            Цикл DO ... WHILE            -->
<!--            -----------------            -->

<?php
    // В отличие от while, цикл do-while или "цикл с постусловием" сначала выполняет код, а затем проверяет условие на истинность: 
    $i = 0;

    do
        echo ++$i;
    while($i < 5);
    /* Результат в браузере:  12345  */

    // Единственное отличие от while - цикл do-while всегда выполняет одну итерацию с не истинным условием.
?>

<!--            --------            -->
<!--            Цикл FOR            -->
<!--            --------            -->

<?php
    // ------
    // Пример
    // ------

    /*
        В цикл for можно передать 3 выражения. 
        Первое будет выполнено только 1 раз, перед началом работы скрипта. 
        Второе - выражение, проверяемое на истинность. 
        Третье выражение будет выполняться после каждой итерации.
    */
    for ($i = 1; $i <= 10; $i++)
        echo $i;
    
    // При желании любое из трёх выражений может быть опущено. Например, так может выглядеть вывод чисел от 1 до 10:
    for($i = 0; $i++ < 10;)
        echo $i;

    // -----------
    // Вечный цикл
    // -----------

    $i = 0;
    for(;;) {
        echo ++$i;

        if($i > 10)
            break; // Прерывание цикла
    }
?>

<!--            -----------------            -->
<!--            Прерывание циклов            -->
<!--            -----------------            -->

<?php
    // ------------------------------
    // Прерывание итерации - continue
    // ------------------------------

        // Оператор continue позволяет пропустить одну итерацию, не мешая дальнейшему выполнению цикла:
        
        $arr = [5, 10, 15];

        foreach($arr as $value)
        {
            if($value === 10) // Прерываем текущую итерацию, но не весь цикл
                continue;

            echo $value, '<br>';
        }
        /*
            Результат в браузере:
            5
            15
        */

    // ------------------------
    // Прерывание цикла - break
    // ------------------------

        // Оператор break прерывает работу цикла:
       
        $arr = [5, 10, 15];

        foreach($arr as $value)
        {
            if($value === 10)
                break;

            echo $value;
        }
        /*
            Результат в браузере:
            5
        */

        // Кроме этого, break позволяет выйти сразу из нескольких циклов, нужно только передать число (иерархию):

        foreach($arr as $value)
        {
            for($i = 0; $i < 10; $i++)
            {
                if($value === 10)
                    break 2; // Выходит сразу из for и foreach

                echo $value, $i, '<br>';
            }
        }
?>

<!--            Далее идет блок с различными --- функциями ---            -->

<!--            ------------------------            -->
<!--            Встроенные функции в PHP            -->
<!--            ------------------------            -->
        
<?php
    /* В PHP существует огромное количество встроенных функций, например var_dump(), print_r(), unset(), phpinfo() и т.д.
        Бессмысленно пытаться запомнить все функции, их просто слишком много.  */
    
    // Чтобы вызвать функцию, необходимо написать круглые скобки после её названия:
    phpinfo();

    // Некоторые функции ожидают, что мы передадим им один или несколько параметров, например функция округления:
    echo ceil(15.5); // выведет 16
    
    // Если функция ожидает несколько значений, их нужно разделять запятыми:
    echo str_replace('язык', 'PHP', 'Это язык');
    /*  Функция str_replace заменяет одно слово (первое значение) на другое (второе значение) в конкретной строке (третье значение). 
        Результат в браузере:
        Это PHP    
    */ 

    // Команда echo не является функцией. Это "синтаксическая конструкция",
?>

<!--            ----------------            -->
<!--            Создание функций            -->
<!--            ----------------            -->

<?php
    // ------------------ 
    // Объявление функции
    // ------------------

        function message()
        {
            echo 'hello';
        }

        message(); // вызов функции

    // ------------------------------------------------- 
    // Аргументы функций и получение значения из функций
    // ------------------------------------------------- 

        // Функция может принимать значения от пользователя и возвращать их:
        function sum($v1, $v2)
        {
            return $v1 + $v2;
        }

        $sum = sum(5, 15); // положит значение 20 в переменную $sum

    // ------------------------------------ 
    // Значения по-умолчанию для переменных
    // ------------------------------------ 

        function sum1($v1, $v2 = 2)
        {
            return $v1 + $v2;
        }

        echo sum1(5, 15); // выведет 20
        echo sum1(5); // выведет 7

    // ---------------------------------------- 
    // Тайп хинтинг (указание типов аргументов) (PHP 7)
    // ---------------------------------------- 

        function make (int $v1, string $v2)
        {
            return $v1 . ' ' . $v2;
        }

        /*
            Если мы передадим в функцию значение, которое можно привести к требуемому типу (например, вместо строки передадим число), значение будет приведено к нужному типу. 
            Если значение привести нельзя (например, массив нельзя превратить в строку), произойдёт ошибка
        */ 
        
        echo make(1, ['текст']); // ошибка, массив нельзя превратить в строку
        echo make('1', 'текст'); // выведет: 1 текст

    // -------------------------- 
    // Тип возвращаемого значения (PHP 7)
    // -------------------------- 

        function sum2($a, $b): float {
            return $a + $b; // Всегда возвращает дробь, даже если результатом будет целое число
        }

    // -------------------------
    // Область видимости функций
    // -------------------------
        
        // Внутри функции видны только те переменные, которые были объявлены внутри функции, либо переданы в неё:
        
        function show() {
            echo $a;
        }

        $a = 5;
        show(); // Ошибка, $a внутри функции не существует

        function edit($a) {
            $a = 10;
        }

        $a = 5;
        edit($a);
        echo $a; // Выведет 5, потому что $a внутри и вне функции - это разные переменные

    // --------------------------------    
    // Глобальные переменные в функциях
    // --------------------------------    

        // Глобальные переменные можно использовать внутри функций с помощью ключевого слова global:

        $var = 5;

        function show1()
        {
            global $var; // Указываем, что $var - глобальная
            echo $var;
        }

        show1(); // выведет 5

        /*
            Использование глобальных переменных является плохим тоном. 
            Они делают код неочевидным и запутанным, функции начинают зависеть от внешних факторов.
            По возможности никогда не используйте глобальные переменные.
        */ 

    // --------------------    
    // Константы в функциях
    // -------------------- 

        // В отличие от переменных, константы видны в любой области видимости:
        
        define('LOGIN1', 'admin');

        function showLogin()
        {
            echo LOGIN1;
        }

        showLogin(); // выведет 'admin'

?>

<!--            -----------------------------------------            -->
<!--            Проверка на существование и пустоту в PHP            -->
<!--            -----------------------------------------            -->

<?php
    // --------------------------------- 
    // Проверка существования переменной
    // ---------------------------------

        // Функция isset() возвращает true, если переменная существует и ее значение не null:
        $name = 'Владимир';
        
        if(isset($name))
            echo 'Здравствувйте, ', $name;
        else
            echo 'Имя не задано';

        // Если в функцию isset() передать несколько переменных, она вернет true при существовании всех переменных:
        $name = 'Василиса';
        $age = 20;

        echo isset($name, $age) ? 'Василиса есть' : 'Василисы нет';
        echo '<br>';
        echo isset($name, $age, $status) ? 'Василиса есть' : 'Василисы нет';
        /*
            Результат в браузере:
            Василиса есть
            Василисы нет
        */

    // ---------------------------- 
    // Операторы объединения с NULL (PHP 7)
    // ----------------------------

        /*  В PHP 7 появился оператор объединения с NULL (или NULL-коалесцентный оператор): ??
            Он позволяет получить значение переменной, если она задана и не равна NULL, а иначе - значение по-умолчанию: */  

        // Как было раньше
        $name = isset($user_name) ? $user_name : 'Безымянный';

        // Как стало в PHP 7
        $name = $user_name ?? 'Безымянный';

        /*  В PHP 7.4 появился присваивающий оператор объединения с NULL: ??=
            Он позволяет удобно задать значение переменной, если эта переменная ещё не задана (либо равна NULL): */
        
        // Как было раньше
        $name = $name ?? 'Василий';

        // Как стало в PHP 7.4
        $name ??= 'Василий';

    // ------------------- 
    // Проверка на пустоту
    // -------------------

        /*  Переменная считается пустой (приводится к false), если она имеет одно из следующих значений:
            
            0 (целое или дробное)
            '' (пустая строка)
            '0' (строка с числом 0)
            [] (пустой массив)
            null
        */ 

        // Функция empty() возвращает true, если переменная не существует или пустая:

        $name = 'Владимир';

        echo isset($name) ? 'Имя задано' : 'Имя не задано';
        echo empty($name) ? 'Имя не задано' : 'Имя задано';

    // ------------------------------ 
    // Существование элемента массива
    // ------------------------------

        /*  Как мы узнали чуть выше, isset() возвращает false, если переменная существует, но имеет значение null.

            Бывают ситуации, когда нам необходимо точно знать, существует ли определённый элемент массива или нет, даже если его значение NULL.

            Для этого в PHP существует функция array_key_exists():
        */ 

        $arr = [null];

        var_dump(isset($arr[0])); // false
        var_dump(array_key_exists(0, $arr)); // true
?>

<!--            -----            -->
<!--            Формы            -->
<!--            -----            -->

<!-- С точки зрения разработчика форма - это набор HTML-элементов, таких как <input>, <select>, <textarea> и пр., 
которые заполняются пользователем, отправляются на сервер и обрабатываются с помощью PHP. -->

<!-- Пример:  В данной форме есть 2 поля для заполнения (input и textarea), а также кнопка отправки формы. -->

<form>
    <input type="text" name="title">  
    <textarea name="content"></textarea>
</form>

<!-- Формы можно передавать с помощью методов GET и POST. Указывается метод с помощью атрибута method тега form.
    Если метод не указан, то по-умолчанию форма отправляется методом GET. -->

<!--    =================================    -->
<!--    Обработка формы с GET-параметрами    -->
<!--    =================================    -->

<!-- Метод GET в формах чаще всего используется для поиска чего-либо (товаров, статей и т.д.). -->

<!-- Формы, отправляемые методом GET, передают данные через URL-адрес.
    Например, разберём URL /index.php?name=Vasya&price=1000 по частям:

        /index.php - ссылка на сам скрипт
        ? - символ, с которого всегда начинается перечисление GET-параметров
        name=Vasya - это первый GET-параметр с ключом name и значением Vasya
        & - разделитель между GET-параметрами
        price=1000 - это второй GET-параметр с ключом price и значением 1000 -->

<!-- Для доступа к этим параметрам существует суперглобальный массив $_GET (доступен из любой области видимости) -->

<?php 
    echo $_GET['name'] . ' ' . $_GET['price'];
?>

<!-- Важно! Каждому элементу формы нужно обязательно указывать атрибут name (это будет ключом элемента), т.к потом браузер кладет в значение то, что ввел пользователь 
и подставляет все это в URL-адрес, на который потом и переходит. Если name не указать, элемент не отправится на сервер -->

<!-- Создадим простую форму и обработчик для нее: -->

<?php
    if(isset($_GET['form'])) {      // Действие, выполняемое при нажатии на кнопку
        echo $_GET['title'] . ' : ' . $_GET['content'] . '<br>';    // Выведет над формой через двоеточие то, что вписал пользователь в поля title и content, например: "Название : Какой-то текст"
    } else {
        echo 'Форма не отправлена';     // До нажатия кнопки над формой будет текст "Форма не отправлена"
    }
?>

<form>      <!-- По умолчанию уже используется метод FORM, поэтому мы его не указываем -->
    <input type="text" name="title">    <!-- Маленькое поле для ввода текста -->
    <br><br>

    <textarea name="content"></textarea>    <!-- Большое поле для ввода текста -->
    <br><br>

    <button name="form">Отправить!</button>     <!-- Кнопка отправки формы на сервер -->
</form>

<!--    ============================    -->
<!--    Обработка формы методом POST    -->
<!--    ============================    -->

<!-- Для отправки форм, которые могут содержать конфиденциальную информацию необходимо использовать метод POST -->

<!-- Аналогично, данные передаваемые методом POST, лежат в суперглобальном массиве $_POST -->

<!-- Перепишем нашу форму под метод POST: -->

<?php
    if(isset($_POST['form'])) {     
        echo $_POST['title'] . ' : ' . $_POST['content'] . '<br>';   
    } else {
        echo 'Форма не отправлена';     
    }
?>

<form method="post">    <!-- Обязательно указываем метод POST -->
    <input type="text" name="title">    
    <br><br>

    <textarea name="content"></textarea>  
    <br><br>

    <button name="form">Отправить!</button>  
</form>

<!--    ===========================    -->
<!--    Изменение обработчика формы    -->
<!--    ===========================    -->

<!-- Обработчик формы - это URL, на который отправится форма. По-умолчанию форма отправляется на тот же URL-адрес, где она находится. -->
<!-- При желании вы можете отправлять форму не на текущий URL, а на какой-нибудь другой. 
    Для этого достаточно указать путь к скрипту в атрибуте action: -->

<form action="/some_url.php">
    <input type="submit">
</form>

<!-- Этот запрос будет отправлен скрипту /some_url.php -->