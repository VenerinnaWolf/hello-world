# Словари: создание, работа со словарем, методы

#            -------            #
#            Словари            #
#            -------            #

# По сути это именованное множество вида ключ: значение
# Изменяемый и итерируемый тип данных.

books = {
  'Гарри Поттер и философский камень': 'Джоан Роулинг',
  'Убить пересмешника': 'Харпер Ли'
}

# ------------------------
# -- Работа со словарем --
# ------------------------

# 1. Создание пустого словаря - {}
empty_dict = {}

# 2. Добавление элементов в словарь - как в списках []
empty_dict[1] = 2
empty_dict['hi'] = 'hello'
print(empty_dict)  # => {1: 2, 'hi': 'hello'}
# Ключом могут быть только неизменяемые типы данных, значением - любой тип данных

# 3. Изменение элементов - аналогично добавлению элементов []
empty_dict[1] = [1, 2]
print(empty_dict)  # => {1: [1, 2], 'hi': 'hello'}

# 4. Доступ к элементу по ключу
print(empty_dict['hi'])  # => 'hello'
# print(empty_dict[2])  # => ошибка, такого ключа нет
# Также есть метод get() - возвращает значение из словаря по ключу, а если ключа не существует, то None

# 5. Удаление элемента - del (это не функция!)
del empty_dict[1]
print(empty_dict)  # => {'hi': 'hello'}
# Также есть метод pop() - удаляет элемент из словаря по ключу и возвращает удаленное значение

# 6. Проверка принадлежности `ключа` словарю - in
if 'hi' in empty_dict:
    print(empty_dict['hi'])

# 7. Перебор словаря:
phones = {'police': 102, 'ambulance': 103, 'firefighters': 101}

# Просто цикл for
for service in phones:
    print(service, phones[service])

# С помощью метода items (возвращает iterable, содержащий в себе кортежи ключ-значение)
for service, phone in phones.items():
    print(service, phone)

# --------------------------------
# -- Методы работы со словарями --
# --------------------------------

# - update() - добавление нескольких элементов:
books.update({
    'Преступление и наказание': 'Фёдор Достоевский',
    'Чемодан': 'Сергей Довлатов'
})

# 1. get() - возвращает значение из словаря по ключу, а если ключа не существует, то None
harryPotterAuthor = books.get('Гарри Поттер и философский камень')  # => 'Джоан Роулинг'

# Вторым параметром можно указать значение, которое будет возвращаться вместо None, если элемент не найден
harryPotterAuthor = books.get('Гарри Поттер в зазеркалье', 'Такого ключа нет')   # => 'Такого ключа нет'

# get удобно использовать для подсчета числа элементов:
numbers = '1 2 3 2 5 2 3 1 5'
seq = map(int, numbers.split())  # в оригинальном примере тут вместо переменной numbers был input()
countDict = {}
for elem in seq:
    countDict[elem] = countDict.get(elem, 0) + 1
for key in sorted(countDict):
    print(key, countDict[key], sep=' : ')

# 2. pop() - удаляет элемент из словаря по ключу и возвращает удаленное значение
harryPotterAuthor = books.pop('Гарри Поттер и философский камень')  # => 'Джоан Роулинг'

# 3. keys() - возвращает все ключи из словаря, без значений
dictKeys = books.keys()  # => dict_keys(['Убить пересмешника', 'Преступление и наказание', 'Чемодан'])

# 4. values() - возвращает все значения из словаря, без ключей
dictValues = books.values()  # => dict_values(['Харпер Ли', 'Фёдор Достоевский', 'Сергей Довлатов'])

# 5. items() - возвращает все пары ключ-значение
# 6. clear() - удаляет все элементы из словаря
# 7. popitem() - удаляет последнюю добавленную пару ключ-значение

# --------------------------
# -- Преобразование типов --
# --------------------------

# -- Преобразование в словарь: dict() --
# На вход функции должен подавать iterable,
# каждый элемент которого тоже является iterable строго с двумя элементами - ключом и значением.
my_dict = dict([['key1', 'value1'], ('key2', 'value2')])
print(my_dict)  # => {'key1': 'value1', 'key2': 'value2'}

# -- Преобразование из словаря --
my_dict = {'a': 1, 'b': 2}

# В строку
print(str(my_dict))  # => '{'a': 1, 'b': 2}'

# В список:
values = list(my_dict.values())  # Список значений: [1, 2]
keys = list(my_dict.keys())  # Список ключей: ['a', 'b']
pairs = list(my_dict.items())  # Список пар ключ-значение: [('a', 1), ('b', 2)]

# Полностью в список с помощью reduce:
from functools import reduce
flat_list = reduce(lambda acc, kv: acc + list(kv), my_dict.items(), [])
print(flat_list)  # => ['a', 1, 'b', 2]

# --------------------------------------
# -- Когда нужно использовать словари --
# --------------------------------------

# - По прямому назначению: сопоставление ключа значению (названия дней недели, переводы слов и т. д.).
# - Для подсчета числа объектов. При очередной встрече объекта счетчик увеличивается на единицу.
#   Это похоже на сортировку подсчётом.
# - Для хранения разреженных массивов. Например, если мы хотим хранить цену 92, 95 и 98 бензина,
#   то могли бы создать массив из 99 элементов и хранить в нём.
#   Но большая часть элементов не нужны - массив разреженный. Словарь здесь подходит больше.
