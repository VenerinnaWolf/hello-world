# Начало функционального программирования.
# Встроенные функции, часто использующиеся в функциональном программировании для работы с последовательностями:
# sum, min, max, sorted, map, filter, enumerate, any, all, zip

#            ----------------------------------------------------            #
#            Встроенные функции для работы с последовательностями            #
#            ----------------------------------------------------            #

# - sum - находит сумму всех элементов iterable.
# - min, max - находит минимум и максимум в последовательности iterable.
# - sorted - возвращает отсортированный iterable (подробнее в файле lists.py)

# -----------
# -- map() --
# -----------

# Применяет некоторую функцию к каждому элементу iterable.
# Принимает два параметра: функцию и итерируемый объект (список, строка и т.д)
# Возвращает объект iterable, где каждый элемент объекта был подвергнут функции

# ! Важно не забывать потом перевести этот iterable в нужный нам тип - список, кортеж и пр.
# В качестве альтернативы, для вывода iterable можно использовать * - это распаковка объекта

my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def mult(x):
    return x*2

r = map(mult, my_list)
print(r)        # => <map object at 0x0000023231186D70> - Тут только ссылка, вычислений еще не произошло
print(*r)       # => 2 4 6 8 10 12 14 16 18
print(list(r))  # => [2, 4, 6, 8, 10, 12, 14, 16, 18]  (Правда если до этого выполнить *r, то тут выведется просто [])

# -- В том числе, в нее можно передавать лямбда-функции --
print(list(map(lambda x: x * x, my_list)))  # => [1, 4, 9, 16, 25, 36, 49, 64, 81]

# -- map - умеет принимать более двух параметров --
# Например, такая запись: map(f, iterA, iterB)
# вернет iterable со значениями f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), ...
# Т.е количество параметров зависит от количества параметров, которые передаются во внутреннюю функцию

# --------------
# -- filter() --
# --------------

# Фильтрация данных по какому-то параметру.
# Применяет функцию predicate ко всем элементам iterable
#   и возвращает iterable, который содержит только те элементы, которые удовлетворили предикату
#   (т.е те элементы, для которых функция-предикат вернула True)

# Например, выведем только положительные числа из списка:
my_list = [1, 2, -1, 5, 6, 0, -2, 2]
print(*filter(lambda x: x > 0, my_list))  # => 1 2 5 6 2

# ! В функциональном программировании обычно переменные используются по минимуму,
# в основном это длинная колбаса из функций от функций от функций...
# Поэтому чаще всего код в функциональном стиле выглядит как-то так:

# Задача: поиск минимального положительного элемента в списке
print(min(filter(lambda x: x > 0, map(int, input().split()))))

# Можно эту запись написать "понятнее" и читать ее, начиная с самого вложенного уровня:

print(                           # 5. Функцией print печатаем элемент на экране
    min(                         # 4. Функцией min находим минимальный элемент из списка
        filter(                  # 3. Функцией filter выбираем из списка только положительные числа
            lambda x: x > 0,
            map(                 # 2. Функцией map приводим полученный список к списку int-ов
                int,
                input().split()  # 1. Читаем данные (строка чисел) и разделяем по пробелам в список
            )
        )
    )
)

# -----------------
# -- enumerate() --
# -----------------

# Нумерует элементы iterable.
# Возвращает кортежи из номера элемента (при нумерации с нуля) и значения очередного элемента.
print(*enumerate("abcde"))  # => (0, 'a') (1, 'b') (2, 'c') (3, 'd') (4, 'e')

# С помощью enumerate, например, удобно перебирать элементы iterable (доступ по индексу в которых невозможен)
# и выводить номера элементов, которые обладают некоторым свойством:
f = open('data.txt', 'r', encoding='utf8')
for i, line in enumerate(f):
    if line.strip() == '':
        print('Blank line at line', i)

# -------------------
# -- any() и all() --
# -------------------

# Возвращают истину, если хотя бы один или все элементы iterable истинны соответственно
# Например, проверим, есть ли / все ли элементы списка имеют модуль <= 10
print(any(map(lambda x: abs(int(x)) <= 10, [1, '6', -4, -11, 15])))  # => True
print(all(map(lambda x: abs(int(x)) <= 10, [1, '6', -4, -11, 15])))  # => False

# -----------
# -- zip() --
# -----------

# Сопоставление элементов из нескольких последовательностей
# zip(iterA, iterB, ...) - конструирует кортежи
# из элементов (iterA[0], iterB[0], ...), (iterA[1], iterB[1], ...), ...


#            ------------------------------------            #
#            Пример задачи в функциональном стиле            #
#            ------------------------------------            #

# Задача.
# В первой строке задано количество людей и автомобилей такси,
# в следующих двух строках расстояние в километрах для каждого человека и цена за километр для каждого такси.
# Необходимо сопоставить каждому человеку номер такси, чтобы суммарная цена поездок была минимальна.
# Идея решения заключается в том, чтобы люди, которым ехать дальше, ехали на более дешевых такси

# Решение в читабельном виде:
input()  # Пропускаем количества, обойдемся без них
people = map(int, input().split())  # вводим расстояние для каждого человека
sortedPeople = sorted(enumerate(people), key=lambda x: x[1])  # нумеруем людей по расстоянию, которое им нужно проехать
taxi = map(int, input().split())  # вводим цены каждого такси
sortedTaxi = sorted(enumerate(taxi), key=lambda x: x[1], reverse=True)  # нумеруем такси в обратном порядке по цене

ans = zip(sortedPeople, sortedTaxi)  # сопоставляем такси и людей
sortedAns = sorted(ans, key=lambda x: x[0][0])  # сортируем сопоставление по номерам людей
print(*map(lambda x: x[1][0], sortedAns))  # выводим номера такси для каждого человека, по порядку

# Решение в функциональном стиле:
input()  # Пропускаем количества, обойдемся без них
print(
    *map(
        lambda x: x[1][0],
        sorted(
            zip(
                sorted(
                    enumerate(
                        map(
                            int,
                            input().split()
                        )
                    ),
                    key=lambda x: x[1]
                ),
                sorted(
                    enumerate(
                        map(
                            int,
                            input().split()
                        )
                    ),
                    key=lambda x: x[1],
                    reverse=True
                )
            ),
            key=lambda x: x[0][0]
        )
    )
)

# Либо мы можем все это слепить в одну строку. Выглядит прекрасно ^^
print(*map(lambda x: x[1][0], sorted(zip(sorted(enumerate(map(int, input().split())), key=lambda x: x[1]), sorted(enumerate(map(int, input().split())), key=lambda x: x[1], reverse=True)), key=lambda x: x[0][0])))
