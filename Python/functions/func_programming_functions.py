# Начало функционального программирования.
# Встроенные функции, часто использующиеся в функциональном программировании для работы с последовательностями:
# sum, min, max, sorted, map, filter, enumerate, any, all, zip

#            ----------------------------------------------------            #
#            Встроенные функции для работы с последовательностями            #
#            ----------------------------------------------------            #

# - sum - находит сумму всех элементов iterable.
# - min, max - находит минимум и максимум в последовательности iterable.
# - sorted - возвращает отсортированный iterable (подробнее в файле lists.py)

# -----------
# -- map() --
# -----------

# Применяет некоторую функцию к каждому элементу iterable.
# Принимает два параметра: функцию и итерируемый объект (список, строка и т.д)
# Возвращает объект iterable, где каждый элемент объекта был подвергнут функции

# ! Важно не забывать потом перевести этот iterable в нужный нам тип - список, кортеж и пр.
# В качестве альтернативы, для вывода iterable можно использовать * - это распаковка объекта

my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def mult(x):
    return x*2

r = map(mult, my_list)
print(r)        # => <map object at 0x0000023231186D70> - Тут только ссылка, вычислений еще не произошло
print(*r)       # => 2 4 6 8 10 12 14 16 18
print(list(r))  # => [2, 4, 6, 8, 10, 12, 14, 16, 18]  (Правда если до этого выполнить *r, то тут выведется просто [])

# -- В том числе, в нее можно передавать лямбда-функции --
print(list(map(lambda x: x * x, my_list)))  # => [1, 4, 9, 16, 25, 36, 49, 64, 81]

# -- map - умеет принимать более двух параметров --
# Например, такая запись: map(f, iterA, iterB)
# вернет iterable со значениями f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), ...
# Т.е количество параметров зависит от количества параметров, которые передаются во внутреннюю функцию

# --------------
# -- filter() --
# --------------

# Фильтрация данных по какому-то параметру.
# Применяет функцию predicate ко всем элементам iterable
#   и возвращает iterable, который содержит только те элементы, которые удовлетворили предикату
#   (т.е те элементы, для которых функция-предикат вернула True)

# Например, выведем только положительные числа из списка:
my_list = [1, 2, -1, 5, 6, 0, -2, 2]
print(*filter(lambda x: x > 0, my_list))  # => 1 2 5 6 2

# ! В функциональном программировании обычно переменные используются по минимуму,
# в основном это длинная колбаса из функций от функций от функций...
# Поэтому чаще всего код в функциональном стиле выглядит как-то так:

# Задача: поиск минимального положительного элемента в списке
print(min(filter(lambda x: x > 0, map(int, input().split()))))

# Можно эту запись написать "понятнее" и читать ее, начиная с самого вложенного уровня:

print(                           # 5. Функцией print печатаем элемент на экране
    min(                         # 4. Функцией min находим минимальный элемент из списка
        filter(                  # 3. Функцией filter выбираем из списка только положительные числа
            lambda x: x > 0,
            map(                 # 2. Функцией map приводим полученный список к списку int-ов
                int,
                input().split()  # 1. Читаем данные (строка чисел) и разделяем по пробелам в список
            )
        )
    )
)

# -----------------
# -- enumerate() --
# -----------------

# Нумерует элементы iterable.
# Возвращает кортежи из номера элемента (при нумерации с нуля) и значения очередного элемента.
print(*enumerate("abcde"))  # => (0, 'a') (1, 'b') (2, 'c') (3, 'd') (4, 'e')

# С помощью enumerate, например, удобно перебирать элементы iterable (доступ по индексу в которых невозможен)
# и выводить номера элементов, которые обладают некоторым свойством:
f = open('data.txt', 'r', encoding='utf8')
for i, line in enumerate(f):
    if line.strip() == '':
        print('Blank line at line', i)

# -------------------
# -- any() и all() --
# -------------------

# Возвращают истину, если хотя бы один или все элементы iterable истинны соответственно
# Например, проверим, есть ли / все ли элементы списка имеют модуль <= 10
print(any(map(lambda x: abs(int(x)) <= 10, [1, '6', -4, -11, 15])))  # => True
print(all(map(lambda x: abs(int(x)) <= 10, [1, '6', -4, -11, 15])))  # => False

# -----------
# -- zip() --
# -----------

# zip(iterA, iterB, ...) - конструирует кортежи
# из элементов (iterA[0], iterB[0], ...), (iterA[1], iterB[1], ...), ...
