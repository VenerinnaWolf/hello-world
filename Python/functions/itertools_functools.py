# Встроенная библиотека itertools - средства для работы с итераторами.
# Комбинаторные средства:
#   combinations() - подмножества из iterable
#   permutations() - перестановки iterable
#   combinations_with_replacement() - перестановки с повторениями
# Другие функции:
#   accumulate() - промежуточные результаты ф-ии для посл-ти (по аналогии с reduce из functools)

# Встроенная библиотека functools - средства для работы с функциями и последовательностями
#   partial() - обертка функций
#   reduce() - последовательное применение ф-ии к элементам посл-ти

#            --------------------            #
#            Библиотека itertools            #
#            --------------------            #

import itertools

# В библиотеке itertools есть различные функции для работы с итераторами.
# Рассмотрим комбинаторные объекты

# -----------------------------------------------
# -- combinations() - подмножества из iterable --
# -----------------------------------------------

# combinations(iterable, r) - генерирует все подмножества размера r из множества iterable.
# Подмножества генерируются в виде кортежей.

print(*itertools.combinations([1, 2, 3], 2))  # => (1, 2) (1, 3) (2, 3)

# Это может быть использовано вместо вложенных циклов при организации перебора.
# Например, мы можем неэффективно решить задачу о поиске трех чисел в последовательности,
# дающих наибольшее произведение:
# nums = list(map(int, input().split()))
nums = [1, 2, 3, 4, 5]
combs = itertools.combinations(range(len(nums)), 3)
print(max(map(lambda x: nums[x[0]] * nums[x[1]] * nums[x[2]], combs)))

# --------------------------------------------
# -- permutations() - перестановки iterable --
# --------------------------------------------

# permutations(iterable) - генерирует все перестановки множества iterable
print(*itertools.permutations([1, 2, 3]))  # => (1, 2, 3) (1, 3, 2) (2, 1, 3) (2, 3, 1) (3, 1, 2) (3, 2, 1)

# permutations(iterable, r) - генерирует все перестановки подмножеств размера r
print(*itertools.permutations([1, 2, 3], 2))  # => (1, 2) (1, 3) (2, 1) (2, 3) (3, 1) (3, 2)

# -------------------------------------------------------------------
# -- combinations_with_replacement() - перестановки с повторениями --
# -------------------------------------------------------------------

# combinations_with_replacement(iterable, r) - генерирует все подмножества iterable размером r с повторениями,
# т.е одно и то же число может входить в подмножество несколько раз.

print(*itertools.combinations_with_replacement([1, 2, 3], 2))  # => (1, 1) (1, 2) (1, 3) (2, 2) (2, 3) (3, 3)

# --------------------------------------------------------------
# -- accumulate() - промежуточные результаты ф-ии для посл-ти --
# --------------------------------------------------------------

# Как reduce() в functools, только накапливает промежуточные результаты выполнения функции
# для элементов последовательности и возвращает iterable этих результатов.
# Т.е для списка [A, B, C], accumulate(list, f) вернет значения A, f(A, B), f(f(A, B), C)

# По умолчанию функция считает промежуточные суммы:
print(*itertools.accumulate([1, 4, 2, 5]))  # => 1 5 7 12
# Результат: 1, 1+4, 1+4+2, 1+4+2+5

# Добавим другую функцию. Например, найдем все промежуточные максимумы элементов списка:
print(*itertools.accumulate([1, 4, 2, 5], max))  # => 1 4 4 5

# Как это отработало:
# 1. Максимум от 1 = 1
# 2. Максимум от результата ^ (1) и 4 = 4
# 3. Максимум от результата ^ (4) и 2 = 4
# 4. Максимум от результата ^ (4) и 5 = 5
# 5. Последовательность завершилась. Выводим все получившиеся результаты: 1 4 4 5


#            --------------------            #
#            Библиотека functools            #
#            --------------------            #

import functools

# В библиотеке functools есть функции для работы с функциями и последовательностями.

# ---------------------------------
# -- partial() - обертка функций --
# ---------------------------------

# Обертка существующих функций с подстановкой некоторых параметров

# Например, обернем функцию print, чтобы она по умолчанию выводила в конце пробел (а не перевод строки)
my_print = functools.partial(print, end=" ")
my_print(1)
my_print(2)
# => 1 2 (через пробел, а не через перевод строки)

# Или мы можем создать обёртку, преобразующую строки из 0 и 1 в числа (из двоичной системы счисления в десятичную):
binStrToInt = functools.partial(int, base=2)
print(binStrToInt('10010'))  # => 18

# ---------------------------------------------------------------------
# -- reduce() - последовательное применение ф-ии к элементам посл-ти --
# ---------------------------------------------------------------------

# Последовательно применяет функцию-предикат к первым элементам последовательности,
#   потом применяет функцию к результату и следующему элементу и тд.
# Т.е для списка myList = [A, B, C] результатом применения reduce(f, myList) будет f(f(A, B), C)

# Главное, чтобы функция-предикат принимала больше параметров, чем возвращает

# Например, мы можем посчитать сумму элементов последовательности
print(functools.reduce(lambda x, y: x + y, [1, 3, 5]))  # => 9

# Как отработал reduce:
# 1. Есть последовательность [1, 3, 5],
# 2. Берем первые два элемента, передаем в функцию: x = 1, y = 3,
# 3. По результатам выполнения функции получаем 4.
# 4. Это число становится новым x = 4. y = 5 - следующий элемент последовательности
# 5. По результатам выполнении функции получаем 9.
# 6. Последовательность закончилась, выводим результат - 9

# Еще один пример: найти НОД всех чисел в iterable
def gcd(a, b):  # функция поиска НОД
    while b != 0:
        a, b = b, a % b
    return a

print(functools.reduce(gcd, map(int, input().split())))

