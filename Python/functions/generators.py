# Генераторы: генераторные выражения, функции генераторы, методы генераторов

#            ----------            #
#            Генераторы            #
#            ----------            #

# Генераторы используют, чтобы оперативная память не давилась большими объёмами информации.
# Когда хранить какой-то объем информации не получится, зато можно обрабатывать каждый элемент последовательно.
# Вычисления с помощью генераторов называются ленивыми, они экономят память.

# - Генератор — это объект, который сразу при создании не вычисляет значения всех своих элементов.
# - Он хранит в памяти только последний вычисленный элемент, правило перехода к следующему
#   и условие, при котором выполнение прерывается.
# - Вычисление следующего значения происходит лишь при выполнении метода next(). Предыдущее значение при этом теряется.

# ---------------------------------------
# -- Итераторы - встроенные генераторы --
# ---------------------------------------

# В Питоне итераторы - это объекты, которые имеют внутреннее состояние
# и метод __next__ для перехода к следующему состоянию.
# Например, можно сконструировать итератор от списка и перебрать все значения:
myList = [1, 2, 3]
for i in iter(myList):
    print(i)
for i in myList:
    print(i)
# Результаты идентичны, т.к список это и так iterable

# Еще один пример итератора - функция range()
sum = 0
for i in range(1000000):
    sum += i
print(sum)
# Если бы мы хранили все эти 1000000 чисел, то забили бы память

# --------------------------
# -- Генераторы-выражения --
# --------------------------

# 1. Создание генераторного выражения:
# Синтаксис: (`выражение` for j in `итерируемый объект` {if `условие`})

# Создадим объект-генератор, который генерирует квадраты чисел от 1 до 4:
a = (i**2 for i in range(1, 5))

# 2. Использование с помощью функции next():
print(next(a))  # => 1
print(next(a))  # => 4
print(next(a))  # => 9
print(next(a))  # => 16
print(next(a))  # => Ошибка, вышли за границы генератора

# 3. Использование с помощью цикла for (в for автоматически вызывается метод next())
a = (i**2 for i in range(1, 5))
for i in a:
    print(i)
# => 1 4 9 16

# При этом генератор закончился, т.е. мы больше не сможем еще раз его использовать

# 4. Еще один пример:
# На сервере есть огромный журнал событий log.txt, в котором хранятся сведения о работе какой-то системы за год.
# Из него нужно выбрать и обработать для статистики данные об ошибках — строки, содержащие слово error.
# Можно решить это с помощью списка, но если ошибок много, он переполнится:
with open("log.txt", "r") as log_file:
    err_list = [st for st in log_file if "error" in st]

# А можно использовать генератор. Тогда мы будем сохранять и обрабатывать только одну ошибку за раз:
with open("log.txt", "r") as log_file:
    err_gen = (st for st in log_file if "error" in st)
    for item in err_gen:
        # тут какая-нибудь обработка строки
        pass

# ------------------------
# -- Функции генераторы --
# ------------------------

# Также генераторы можно создавать в виде функций, которые возвращают значение словом yield
# Отличие return и yield:
# - return завершает работу функции
# - yield лишь приостанавливает работу функции, при этом она возвращает какое-то значение

# При этом при возвращении на следующую итерацию функции-генератора, она запоминает предыдущее значение.
# При первом вызове метода next() выполняется код функции с первой команды до yield.
# При втором next() и последующих до конца генератора
#   — код со следующей после yield команды и до тех пор, пока yield не встретится снова

# Например, запишем упрощенный генератор (i**2 for i in range(1, n)) в виде функции:
def f_gen(n):
    for i in range(1, n):
        yield i**2

for i in f_gen(5):
    print(i)
# => 1 4 9 16

# Таким образом можно сделать, например, аналог встроенного range:
def my_range(n):
    i = 0
    while i < n:
        yield i
        i += 1

sum = 0
for i in my_range(1000000):
    sum += i
print(sum)

# 1. Т.к. генератор - это итерируемый объект, его можно вывести с помощью *:
print(my_range(10))   # => <generator object my_range at 0x00000206D0FD5B40>
print(*my_range(10))  # => 0 1 2 3 4 5 6 7 8 9

# 2. Генераторы могут иметь сложную рекурсивную структуру

# Например, генератор, который будет выдавать все числа заданной длины,
# цифры в которых не убывают и старшая цифра не превосходит заданного параметра:
def gen_dec_digs(cnt_digits, max_digit):
    if cnt_digits > 0:
        for nowDigit in range(max_digit + 1):
            for tail in gen_dec_digs(cnt_digits - 1, nowDigit):
                yield nowDigit * 10 ** (cnt_digits - 1) + tail
    else:
        yield 0

print(*gen_dec_digs(2, 3))  # => 0 10 11 20 21 22 30 31 32 33

# 3. У генератора может быть несколько yield

# В этом случае команды yield служат разделителями кода:
# при первом вызове метода next() выполняется код до первого yield,
# при следующих вызовах — операторы между yield.
# При этом в генераторной функции необязательно должен быть цикл, все значения генератора и так посчитаются.
def gen():
    yield 1
    yield 2
    yield 3
print(*gen())  # => 1 2 3

# 4. Можно создавать бесконечные последовательности, если в генераторе будет бесконечный цикл:
import math
def prime_num():
    nm = 2
    while True:
        sq = math.ceil(nm**1/2)
        for i in range(2, sq+1):
            if (nm % i) == 0:
                break
            else:
                yield nm
            nm += 1

for num in prime_num():
    print(num)
# => бесконечно будет печатать простые числа: 2 3 5 7 ...

# ------------------------
# -- Методы генераторов --
# ------------------------

# Когда-то был один next (), но в Python 2.5 появилось ещё три метода:
# .close () — останавливает выполнение генератора;
# .throw () — генератор бросает исключение;
# .send () — интересный метод, позволяет отправлять значения генератору.

def f_gen():
    n = 1
    while True:
        yield n**2
        n += 1

# 1. Пример с close():

generator1 = f_gen()
for i in generator1:
    print(i)
    if i > 10:
        generator1.close()
# => 1 4 9 16

# 2. Пример с throw():

generator2 = f_gen()
for i in generator2:
    print(i)
    if i > 20:
        generator2.throw(Exception("Слишком много!"))
# => 1 4 9 16 25 Exception: "Слишком много!"

# 3. Примеры с send():

# Обратный таймер отсчета:
def countdown(start):
    current = start
    while current > 0:
        received = (yield current)
        current = received if received is not None else current - 1

gen = countdown(5)
print(next(gen))    # => 5. Запускаем обратный отсчёт.
print(gen.send(3))  # => 3. Это нечто вроде фокуса!
print(next(gen))    # => 2. Продолжаем обратный отсчёт.
print(gen.send(6))  # => 6. Вернулись во времени

# Светофор
def traffic_light():
    color = 'Зелёный'
    while True:
        color = (yield color)
        color = 'Красный' if color == 'Жёлтый' else 'Зелёный'

light = traffic_light()
print(next(light))           # => 'Зелёный'
print(light.send('Жёлтый'))  # => 'Красный'
