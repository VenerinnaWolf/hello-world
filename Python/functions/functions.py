# Встроенные функции, создание собственных функций, лямбда-функции

#            -------            #
#            Функции            #
#            -------            #

# ------------------------
# -- Встроенные функции --
# ------------------------

# -- Есть стандартная библиотека, и в ней есть тысячи функций --
# Справочник встроенных функций: https://docs-python.ru/standart-library/

# -- Есть функции, а есть методы --
# Метод - это действие над объектом, и вызывается через точку
name = 'Python'
print(name)     # Функция
name.lower()    # Метод

# -- Некоторые методы дублируют функции (или наоборот) --
# Такие методы, которые не предназначены для прямого вызова, обернуты в __
x = -5
abs(x)          # вызывает x.__abs__() - модуль числа x
pow(x, 3)       # вызывает x.__pow__(3) - x в степени 3
len('Hexlet')   # вызывает 'Hexlet'.__len__() - длина строки

# -- map() --

# Эта функция принимает два параметра: функцию и итерируемый объект (список, строка и т.д)
# Возвращает объект iterable, где каждый элемент объекта был подвергнут функции
# ! Важно не забывать потом перевести этот iterable в нужный нам тип - список, кортеж и пр.

ls = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def my_func(x):
    return x*2

r = map(my_func, ls)
print(r)        # => ... Тут только ссылка, вычислений еще не произошло
print(list(r))  # => [2, 4, 6, 8, 10, 12, 14, 16, 18]

# В том числе, в нее можно передавать лямбда-функции
list(map(lambda x: x * x, ls))  # => [1, 4, 9, 16, 25, 36, 49, 64, 81]

# ----------------------------------
# -- Создание собственных функций --
# ----------------------------------

# -- Определение функции --

# Описание функции может быть где угодно в коде, раньше первого ее вызова.
# Перед функцией и после должно быть две строки (так требует flake8), я это тут пропускаю
# Некоторым параметрам можно передать значение по умолчанию (=...),
#   такие параметры должны идти в самом конце списка параметров.

def my_function(x, y, a=5, b=10, c=100):
    # Внутри тела отступ четыре пробела или одна табуляция
    sum = x + y
    info = f'Сумма = {sum}. Параметры: а = {a}, b = {b}, c = {c}'
    return info

print(my_function(1, 2))  # Вызов ранее определенной функции

# -- Возврат нескольких значений функцией (кортеж) --

def sort2(a, b):
    if a < b:
        return a, b
    else:
        return b, a

min, max = sort2(3, 2)
print(min, max)

# -- Рекурсивная функция --

def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

print(factorial(10))

# -- Минимальное определение функции --
# Если функция пустая, пишем внутри pass

def noop():
    pass

# --------------------
# -- Лямбда-функции --
# --------------------

# Простая функция, которая используется сразу в месте создания и не имеет имени.

# Функция, возводящая число в квадрат:
def sqr(x):
    return x**2

# Аналогичная лямбда-функция:
lambda x: x**2

# -- Обычно лямбда-функции передаются в качестве параметра --
# Например, в функцию map()
print(' '.join(map(lambda x: str(x**2), range(1, 101))))  # Квадраты чисел от 1 до 100

# -- Можно создать ссылку на объект типа функция --
# Получится что-то вроде названия функции. Лучше тогда уж использовать def
lambda_sqr = lambda x: x ** 2
print(lambda_sqr(3))

# -------------------------------------
# --     Именованные параметры и     --
# -- неопределенное число параметров --
# -------------------------------------

# Именованные параметры - это параметры со значениями по умолчанию (=...)
# Просто их можно передавать с именем, а можно без (если такой параметр один)

def print_list(my_list, sep=' ', info=''):
    print(sep.join(map(str, my_list)))
    print(info)

print_list([1, 2, 3])            # 1 2 3
print_list([3, 2, 1], sep='\n')  # В столбик 3 2 1
print_list([1, 2], ' + ')        # 1 + 2
print_list([5, 6], info='info')  # 5 6 на следующей строчке 'info'

# Неопределенное число параметров пишется через звездочку *args
# В этом случае *args автоматически будет упаковано в список

def my_sum(*args):
    now_sum = 0
    for now in args:
        now_sum += now
    return now_sum

print(my_sum(1, 2))
print(my_sum(1, 2, 3, 4))

# Можно указывать и другие обязательные параметры,
#   но параметр со звездочкой всегда должен быть последним
# Если есть именованные параметры, они идут после параметра со звездочкой

def my_min(first, *others):
    now_min = first
    for now in others:
        if now < now_min:
            now_min = now
    return now_min

print(my_min(1))
print(my_min(3, 1, 2))

# Итак, сначала обычные параметры, потом со звездочкой, потом именованные
