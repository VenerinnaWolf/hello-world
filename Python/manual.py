# Мануал пишу по этому курсу на code basics:
# https://code-basics.com/ru/languages/python
# И по курсу от ВШЭ на coursera:
# https://www.coursera.org/learn/python-osnovy-programmirovaniya/

#            -------------------------------            #
#            Вывод на экран. Функция print()            # 
#            -------------------------------            #

print("Hello, World!")

# -- Функция print() может принимать несколько параметров --

# По умолчанию она ставит пробел между парамерами
print('2 + 3 =', 2 + 3)  # => 2 + 3 = 5
# Но можно установить свой разделитель sep (любую строку)
print(1, 2, 3, 4, sep=' + ')  # => 1 + 2 + 3 + 4

# После каждой функции print() по умолчанию осуществляется перевод строки
# Чтобы это изменить, можно установить свой параметр end (любую строку)

print(1, 2, 3, 4, sep=' + ', end='')
print(' = ', 1 + 2 + 3 + 4, sep='')
# => 1 + 2 + 3 + 4 = 10


#            ------------------------------            #
#            Чтение данных. Функция input()            # 
#            ------------------------------            #

name = input()
print('I love', name)

# Функция input() всегда возвращает строку
# Чтобы иметь другой тип данных, придется привести к нему:
a = int(input())
b = int(input())
print(a + b)


#            -----------------------------            #
#            Линтер (стандарт кодирования)            #
#            -----------------------------            #

# Общий стандарт в Python - PEP8 https://peps.python.org/pep-0008/
# Программы, проверяющие на соответствие этому стандарту называются линтерами.
# Самый популярный линтер:
# flake8 https://flake8.pycqa.org/en/latest/user/error-codes.html


#            -----------------------            #
#            Арифметические операции            # 
#            -----------------------            #

1 + 2   # сложение
1 - 2   # вычитание
1 * 2   # умножение
1 ** 2  # возведение в степень
1 / 2   # деление (результат - float)
1 // 2  # целочисленное деление
1 % 2   # остаток от деления
-3      # унарный оператор -

# Чтобы вывести результат на экран, нужно написать print:
print(1 + 2)    # => 3
print(-8 / -4)  # => 2.0 (то есть можно минусы в скобочки не ставить)


#            ---------------------            #
#            Кавычки и спецсимволы            # 
#            ---------------------            #

# -- Спецсимволы --

# Экранирование \
# Переход на следующую строку \n
# Табуляция \t,
# Возврат каретки \r — работает только в Windows
print("- Are you hungry?\n- Aaaarrrgh!")

# Экранирование (\) кавычек
print("Dragon's mother said \"No\"")

# Экранирование обратного слеша
print("\\")     # => \


#            ------            #
#            Строки            # 
#            ------            #

# -- Умножение на число --
print('+' * 5)  # => '+++++'

# -------------------------------------
# -- 5 способов форматирования строк --
# -------------------------------------

name = "Дмитрий"
age = 25

# 1. Конкатенация
print("Меня зовут " + name + ". Мне " + str(age) + " лет.")

# 2. %-форматирование

# Передавать значения в строку можно через списки, кортежи и словари.
# Во втором случае значения помещаются не по позиции, а по имени.
print("Меня зовут %s. Мне %d лет." % (name, age))
print("Меня зовут %(name)s. Мне %(age)d лет." % {"name": name, "age": age})

# 3. Template-строки
s = Template('Меня зовут $name. Мне $age лет.')
print(s.substitute(name=name, age=age))

# 4. Форматирование с помощью метода format()
print("Меня зовут {}. Мне {} лет.".format(name, age))
print("Меня зовут {name} Мне {age} лет.".format(age=age, name=name))

# 5. Интерполяция или же f-строки.
print(f"Меня зовут {name} Мне {age} лет.")

# -----------------------
# -- Multi-line строки --
# -----------------------

# Пишется внутри тройных кавычек (как """, так и ''')
# Не требует написания \n для переноса строки
# Не требует экранирования кавычек
text = """Здесь не нужно экранировать
'одинарные' и
"двойные" кавычки"""

# -- Из таких строк можно делать f-строки --
a = 'A'
b = 'B'
text = f'''{a} и {b}
сидели на трубе'''

# -----------------------
# -- Некоторые функции --
# -----------------------

# -- Длина строки: len() --
print(len('Hello!'))  # => 6

# -- Символ из кодировки ASCII --
print(chr(63))  # => Символ "?"

# -- Приведение типа к строке --
str(5)

# ----------------------
# -- Некоторые методы --
# ----------------------

name = 'Python'

# -- Индекс первого вхождения подстроки в строку: .find() --
name.find('th')        # 2
# Второй необязательный параметр - начало (поиск в подстроке s[from:])
name.find('th', 2)     # 2 (нумерация останется как в исходной строке)
# Третий необязательный параметр - конец (поиск в подстроке s[a:b])
name.find('th', 2, 5)  # 2 (нумерация останется как в исходной строке)
# Если вхождение не найдено, возвращает -1

# -- Индекс последнего вхождения подстроки в строку: .rfind() --
'abcda'.rfind('a')     # 4
# Аналогично с find имеет второй и третий необязательные параметры

# -- Замена всех вхождений подстроки old на подстроку new: .replace() --
name.replace('on', 'off')  # 'Pythoff'
'AAAAAA'.replace('AA', 'A')  # 'AAA', а не 'A'
# Модификация replace(old, new, count) осуществляет не более count замен
'AAAAAA'.replace('AA', 'A', 1)  # 'AAAAA'

# -- Количество вхождений подстроки: .count() --
'AAAAAA'.count('AA')   # 3
# Аналогично с find имеет второй и третий необязательные параметры

# -- Верхний регистр: .upper() --
name.upper()  # => 'PYTHON'

# -- Нижний регистр: .lower() --
name.lower()  # 'python'


#            -----------------------            #
#            Срез строки (подстрока)            # 
#            -----------------------            #

# Спецсимволы вроде \n считаются за один символ
# Отрицательные индексы начинают отсчет от конца строки

# --------------------------
# -- Обращение по индексу --
# --------------------------

# Это простейший срез с одним параметром

first_name = 'Alexander'
print(first_name[0])  # => A
print(first_name[-1])  # => r

# Наглядно продемонстрирую нумерацию символов в строке "Hexlet":
#    H     e     x     l     e     t
#   [0]   [1]   [2]   [3]   [4]   [5]
#   [-6]  [-5]  [-4]  [-3]  [-2]  [-1]

# Изменять значение по индексу нельзя
first_name[0] = 'B'  # TypeError: 'str' object does not support item assignment

# ------------------------------
# -- Срез с двумя параметрами --
# ------------------------------

date = '12-08-2034'
year = date[6:10]  # подстрока с 6 индекса по 10 индекс, не включая 10-й
print(year)  # => 2034

value = 'Hexlet'

# -- Можно не указывать одну из границ --
value[3:]    # 'let'
value[:3]    # 'Hex'
value[:]     # 'Hexlet'

# -- Можно указывать отрицательные индексы --

# Правая граница отрицательная. Считаем -1 от конца строки
value[3:-1]  # 'le'
# Левая граница отрицательная. Считаем -5 от конца строки
value[-5:3]  # 'ex'

# -- Если первый параметр находится правее второго, получим пустую строку --
value[3:1]   # ''

# --------------------
# -- Шаг извлечения --
# --------------------

# Добавим необязательный третий параметр

# По умолчанию этот шаг = 1.
# Шаг 2 это каждый второй в подстроке (индексы [0], [2] и т.д).
# Если взять срез S[a:b:d],
#   то в результате будут взяты символы с индексами a, a+d, a+2*d и т.д

value[1:5:2]  # el
# 1:5 это подстрока 'exle'
# 1:5:2 - шаг 2 это [0], [2] и т.д, то есть 'e' и 'l'

value[:5:2]   # 'Hxe'
value[1::2]   # 'elt'

# -- Отрицательный шаг извлечения --

# Переворот строки
value[::-1]  # 'telxeH'
# Если шаг отрицательный, и элементы извлекаются в обратном порядке
#   — тогда и границы среза тоже нужно указывать в обратном порядке.
# Первой указывается правая граница среза, второй — левая:
value[4:1:-1]  # 'elx'


#            ---------            #
#            Пременные            # 
#            ---------            #

first = "Kings"
last = 'road'
what = first + last

euros_count = 100
dollars = euros_count * 1.25

# -- Подходы к именованию переменных --

# kebab-case — составные части переменной разделяются дефисом (my-super-var)
# snake_case — для разделения используется подчеркивание (my_super_var)
# CamelCase — каждое слово в переменной пишется с заглавной буквы (MySuperVar)
# В Python используется snake_case

# -- Костанты --
# Те же переменные, но пишутся заглавными буквами (и, увы, их можно поменять)
PI = 3.14


#            --------------------------            #
#            Явное преобразование типов            # 
#            --------------------------            #

# Python - язык со строгой типизацией, в отличие от PHP или JavaScript

# ------------------------------------------
# -- int() - преобразование в целое число --
# ------------------------------------------

# -- Строки --
converted_value = int('10')    # => 10
converted_value = int('')      # => Ошибка ValueError
converted_value = int('Text')  # => Ошибка ValueError

# -- Булевые переменные --
converted_value = int(False)   # => 0
converted_value = int(True)    # => 1

# -- Вещественные числа --
converted_value = int(3.61)     # => 3

# -------------------------------------
# -- str() - преобразование в строку --
# -------------------------------------

value = str(10)    # '10'
value = str(10.1)  # '10.1'
value = str(True)  # 'True'
value = str()      # ''

# ---------------------------------------------------
# -- float() - преобразование в вещественное число --
# ---------------------------------------------------

value = float(5)   # 5.0

# В операциях с float, все int неявно преобразуются в float
# Неявно выполняется код float(3) + 1.2
value = 3 + 1.2    # 4.2


#            ------------------            #
#            Вещественные числа            # 
#            ------------------            #

# -- Вывод определенного количества знаков после запятой --

x = 0.1
print('{0:.25f}'.format(x))
# 25 знаков после запятой => 0.1000000000000000055511151

# ----------------------------------
# -- Сравнение вещественных чисел --
# ----------------------------------

# Вещественные числа не точные!
0.1 + 0.2 == 0.3  # => False

# Для их сравнения, нужно учитывать погрешность:
x = 0.1 + 0.2
y = 0.3
epsilon = 10 ** -6  # Погрешность с точностью до 6 знаков после запятой
if abs(x - y) < epsilon:
    print('Equal')
else:
    print('Not equal')

# -----------------------------------
# -- Округление вещественных чисел --
# -----------------------------------

# int   - округляет в сторону нуля (отбрасывет дробную часть)
# round - округляет до ближайшего целого,
#         если дробная часть равна 0.5, то к чётному
# floor - округляет в меньшую сторону
# ceil  - округляет в большую сторону
# trunc - работает как int

# Функции floor, ceil и trunc находятся в библиотеке math
# Как ими воспользоваться? (Все импорты должны быть вверху файла)

# 1
import math

print(math.floor(-2.5))
print(math.ceil(-2.5))

# 2
from math import floor, ceil

print(floor(-2.5))
print(ceil(-2.5))


#            ---------------------            #
#            Логический тип данных            # 
#            ---------------------            #

# Тип переменной - bool
# Принимаемые значения: True и False

# -- Знаки сравнения --

#  <   - меньше
#  >   - больше
#  <=  - меньше либо равно
#  >=  - больше либо равно
#  !=  - не равно
#  ==  - равно (проверяет равенство двух значений)
#  is  - равно (проверяет, указывают ли объекты на одну и ту же область памяти)

a = [1, 2, 3]
b = [1, 2, 3]
print(a == b)  # => True
print(a is b)  # => False
# Для экономии памяти, булевы типы, числа и строки могут кешироваться
# Тогда is вернет True, даже если переменные разные, но имеют одно значение

# В выражении можно использовать несколько знаков сравнения: x < y < z

# -- Логические операции --
# Имеют приоритет ниже, чем операции сравнения

#  and - и
#  or  - или
#  not - не


#            ------------------------------            #
#            Условный оператор: if ... else            # 
#            ------------------------------            #

# Обязательно соблюдать отступ в 4 пробела или один tab.
# Блок else необязателен

x = int(input())
if x >= 0:
    print(x)
else:
    print(-x)

# ---------------------------------
# -- Вложенный условный оператор --
# ---------------------------------

eyes = int(input())
legs = int(input())
if eyes >= 8:
    if legs == 8:
        print("spider")
    else:
        print("scallop")
else:
    if legs == 6:
        print("bug")
    else:
        print("cat")

# -------------------------------
# -- Конструкция "иначе-если" --
# --   if ... elif ... else   --
# -------------------------------

number = int(input())
if number == 1:
    print('One')
elif number == 2:
    print('Two')
else:
    print('Other')


#            -----------            #
#            Цикл: while            # 
#            -----------            #

# Например, выведем все числа по возрастанию от 1 до N:
n = int(input())
i = 1
while i <= n:
    print(i)
    i = i + 1

# Или найдем минимум в последовательности (оканчивается на 0):
now = int(input())
nowMin = now
while now != 0:
    if now < nowMin:
        nowMin = now
    now = int(input())
print(nowMin)

# -- Оператор остановки: break --

# После выполнения break работа цикла прекращается

i = 1
while True:
    print(i)
    i = i + 1
    if i > 100:
        break

# В Python к циклу while можно написать блок else.
# Команды в этом блоке будут выполняться, если цикл завершил свою работу
#   нормальным образом (т.е. условие в какой-то момент перестало быть истинным)
# и не будут выполняться только в случае,
#   если выход из цикла произошел с помощью команды break.

# -- Оператор продолжения: continue --

# continue начинает исполнение тела цикла заново, начиная с проверки условия

# Например, дана последовательность чисел. Вывести все положительные числа
now = -1
while now != 0:
    now = int(input())
    if now <= 0:
        continue
    print(now)


#            -------            #
#            Функции            # 
#            -------            #

# ------------------------
# -- Встроенные функции --
# ------------------------

# -- Есть стандартная библиотека, и в ней есть тысячи функций --
# Справочник встроенных функций: https://docs-python.ru/standart-library/

# -- Есть функции, а есть методы --
# Метод - это действие над объектом, и вызывается через точку
name = 'Python'
print(name)     # Функция
name.lower()    # Метод

# -- Некоторые методы дублируют функции (или наоборот) --
# Такие методы, которые не предназначены для прямого вызова, обернуты в __
x = -5
abs(x)          # вызывает x.__abs__() - модуль числа x
pow(x, 3)       # вызывает x.__pow__(3) - x в степени 3
len('Hexlet')   # вызывает 'Hexlet'.__len__()

# ----------------------------------
# -- Создание собственных функций --
# ----------------------------------

# -- Определение функции --

# Описание функции может быть где угодно в коде, раньше первого ее вызова.
# Перед функцией и после обязательно должно быть две строки.
# Сначала пишутся обязательные параметры функции через запятую.
# Некоторым параметрам можно передать значение по умолчанию (=...)
# Они должны идти в самом конце списка параметров.


def my_function(x, y, a=5, b=10, c=100):
    # Внутри тела отступ четыре пробела или одна табуляция
    sum = x + y
    info = f'Сумма = {sum}. Параметры: а = {a}, b = {b}, c = {c}'
    return info


print(my_function(1, 2))

# -- Минимальное определение функции --
# Еесли функция пустая, пишем внутри pass


def noop():
    pass


#            -------            #
#            Объекты            # 
#            -------            #

# У объектов есть атрибуты и методы

# ------------------------
# -- Встроенные объекты --
# ------------------------

# Например, строка - это объект в Python.

# -- Методы --

first_name = '  Grigor   \n'
print(first_name.strip())  # 'Grigor'

# Примитивные методы не меняют само содержимое переменной
name = 'Tirion'
print(name.upper())  # => TIRION
print(name)  # => Tirion

# -- Атрибуты --

# Например, артибут, возвращающий документацию функции:
len.__doc__  # 'Return the number of items in a container.'

# Атрибуты работают и выглядят как переменные,
# только указываются через точку после объекта.
