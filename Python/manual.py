# Мануал пишу по этому курсу на code basics:
# https://code-basics.com/ru/languages/python
# И по курсу от ВШЭ на coursera:
# https://www.coursera.org/learn/python-osnovy-programmirovaniya/

#            -------------------------------            #
#            Вывод на экран. Функция print()            # 
#            -------------------------------            #

print("Hello, World!")

# -- Функция print() может принимать несколько параметров --

# По умолчанию она ставит пробел между парамерами
print('2 + 3 =', 2 + 3)  # => 2 + 3 = 5
# Но можно установить свой разделитель sep (любую строку)
print(1, 2, 3, 4, sep=' + ')  # => 1 + 2 + 3 + 4

# После каждой функции print() по умолчанию осуществляется перевод строки
# Чтобы это изменить, можно установить свой параметр end (любую строку)

print(1, 2, 3, 4, sep=' + ', end='')
print(' = ', 1 + 2 + 3 + 4, sep='')
# => 1 + 2 + 3 + 4 = 10


#            ------------------------------            #
#            Чтение данных. Функция input()            # 
#            ------------------------------            #

name = input()
print('I love', name)

# Функция input() всегда возвращает строку
# Чтобы иметь другой тип данных, придется привести к нему:
a = int(input())
b = int(input())
print(a + b)


#            -----------------------------            #
#            Линтер (стандарт кодирования)            #
#            -----------------------------            #

# Общий стандарт в Python - PEP8 https://peps.python.org/pep-0008/
# Программы, проверяющие на соответствие этому стандарту называются линтерами.
# Самый популярный линтер:
# flake8 https://flake8.pycqa.org/en/latest/user/error-codes.html


#            -----------------------            #
#            Арифметические операции            # 
#            -----------------------            #

1 + 2   # сложение
1 - 2   # вычитание
1 * 2   # умножение
1 ** 2  # возведение в степень
1 / 2   # деление (результат - float)
1 // 2  # целочисленное деление
1 % 2   # остаток от деления
-3      # унарный оператор -

# Чтобы вывести результат на экран, нужно написать print:
print(1 + 2)    # => 3
print(-8 / -4)  # => 2.0 (то есть можно минусы в скобочки не ставить)


#            ---------------------            #
#            Кавычки и спецсимволы            # 
#            ---------------------            #

# -- Спецсимволы --

# Экранирование \
# Переход на следующую строку \n
# Табуляция \t,
# Возврат каретки \r — работает только в Windows
print("- Are you hungry?\n- Aaaarrrgh!")

# Экранирование (\) кавычек
print("Dragon's mother said \"No\"")

# Экранирование обратного слеша
print("\\")     # => \


# - - - - - - - - - - Различные типы данных - - - - - - - - - - #

#            ------            #
#            Строки            # 
#            ------            #

# -- Умножение на число --
print('+' * 5)  # => '+++++'

# -------------------------------------
# -- 5 способов форматирования строк --
# -------------------------------------

name = "Дмитрий"
age = 25

# 1. Конкатенация
print("Меня зовут " + name + ". Мне " + str(age) + " лет.")

# 2. %-форматирование

# Передавать значения в строку можно через списки, кортежи и словари.
# Во втором случае значения помещаются не по позиции, а по имени.
print("Меня зовут %s. Мне %d лет." % (name, age))
print("Меня зовут %(name)s. Мне %(age)d лет." % {"name": name, "age": age})

# 3. Template-строки
s = Template('Меня зовут $name. Мне $age лет.')
print(s.substitute(name=name, age=age))

# 4. Форматирование с помощью метода format()
print("Меня зовут {}. Мне {} лет.".format(name, age))
print("Меня зовут {name} Мне {age} лет.".format(age=age, name=name))

# 5. Интерполяция или же f-строки.
print(f"Меня зовут {name} Мне {age} лет.")

# -----------------------
# -- Multi-line строки --
# -----------------------

# Пишется внутри тройных кавычек (как """, так и ''')
# Не требует написания \n для переноса строки
# Не требует экранирования кавычек
text = """Здесь не нужно экранировать
'одинарные' и
"двойные" кавычки"""

# -- Из таких строк можно делать f-строки --
a = 'A'
b = 'B'
text = f'''{a} и {b}
сидели на трубе'''

# -----------------------
# -- Некоторые функции --
# -----------------------

# -- Длина строки: len() --
print(len('Hello!'))  # => 6

# -- Перевод значения Unicode в символ --
print(chr(63))   # => '?'

# -- Перевод символа в номер в кодировке Unicode --
print(ord('?'))  # => 63

# -- Преобразование типа в строку --
str(5)

# ----------------------
# -- Некоторые методы --
# ----------------------

name = 'Python'

# -- .find() --

# Индекс первого вхождения подстроки в строку
name.find('th')        # 2
# Второй необязательный параметр - начало (поиск в подстроке s[from:])
name.find('th', 2)     # 2 (нумерация останется как в исходной строке)
# Третий необязательный параметр - конец (поиск в подстроке s[a:b])
name.find('th', 2, 5)  # 2 (нумерация останется как в исходной строке)
# Если вхождение не найдено, возвращает -1

# -- .rfind() --

# Индекс последнего вхождения подстроки в строку
'abcda'.rfind('a')     # 4
# Аналогично с find имеет второй и третий необязательные параметры

# -- .replace(old, new) --

# Замена всех вхождений подстроки old на подстроку new
name.replace('on', 'off')  # 'Pythoff'
'AAAAAA'.replace('AA', 'A')  # 'AAA', а не 'A'
# Модификация replace(old, new, count) осуществляет не более count замен
'AAAAAA'.replace('AA', 'A', 1)  # 'AAAAA'

# -- .count() --

# Количество вхождений подстроки
'AAAAAA'.count('AA')   # 3
# Аналогично с find имеет второй и третий необязательные параметры

# -- Верхний регистр: .upper() --
name.upper()  # => 'PYTHON'

# -- Нижний регистр: .lower() --
name.lower()  # 'python'

# -- Разрезание строки: .split() --

# Разрезает по пробелам, табуляциям и переводам строк. Возвращает список
print('red green        blue'.split())  # => ['red', 'green', 'blue']

# -- Склеивание строки: .join() --

# Вызывается от разделителя между элементами. Принимает только iterable строк
print(', '.join(['Veni', 'Vidi', 'Vici']))  # => 'Veni, Vidi, Vici'


#            -----------------------            #
#            Срез строки (подстрока)            # 
#            -----------------------            #

# Спецсимволы вроде \n считаются за один символ
# Отрицательные индексы начинают отсчет от конца строки

# --------------------------
# -- Обращение по индексу --
# --------------------------

# Это простейший срез с одним параметром

first_name = 'Alexander'
print(first_name[0])  # => A
print(first_name[-1])  # => r

# Наглядно продемонстрирую нумерацию символов в строке "Hexlet":
#    H     e     x     l     e     t
#   [0]   [1]   [2]   [3]   [4]   [5]
#   [-6]  [-5]  [-4]  [-3]  [-2]  [-1]

# Изменять значение по индексу нельзя
first_name[0] = 'B'  # TypeError: 'str' object does not support item assignment

# ------------------------------
# -- Срез с двумя параметрами --
# ------------------------------

date = '12-08-2034'
year = date[6:10]  # подстрока с 6 индекса по 10 индекс, не включая 10-й
print(year)  # => 2034

value = 'Hexlet'

# -- Можно не указывать одну из границ --
value[3:]    # 'let'
value[:3]    # 'Hex'
value[:]     # 'Hexlet'

# -- Можно указывать отрицательные индексы --

# Правая граница отрицательная. Считаем -1 от конца строки
value[3:-1]  # 'le'
# Левая граница отрицательная. Считаем -5 от конца строки
value[-5:3]  # 'ex'

# -- Если первый параметр находится правее второго, получим пустую строку --
value[3:1]   # ''

# --------------------
# -- Шаг извлечения --
# --------------------

# Добавим необязательный третий параметр

# По умолчанию этот шаг = 1.
# Шаг 2 это каждый второй в подстроке (индексы [0], [2] и т.д).
# Если взять срез S[a:b:d],
#   то в результате будут взяты символы с индексами a, a+d, a+2*d и т.д

value[1:5:2]  # el
# 1:5 это подстрока 'exle'
# 1:5:2 - шаг 2 это [0], [2] и т.д, то есть 'e' и 'l'

value[:5:2]   # 'Hxe'
value[1::2]   # 'elt'

# -- Отрицательный шаг извлечения --

# Переворот строки
value[::-1]  # 'telxeH'
# Если шаг отрицательный, и элементы извлекаются в обратном порядке
#   — тогда и границы среза тоже нужно указывать в обратном порядке.
# Первой указывается правая граница среза, второй — левая:
value[4:1:-1]  # 'elx'


#            ------------------            #
#            Вещественные числа            # 
#            ------------------            #

# -- Вывод определенного количества знаков после запятой --

x = 0.1
print('{0:.25f}'.format(x))
# 25 знаков после запятой => 0.1000000000000000055511151

# ----------------------------------
# -- Сравнение вещественных чисел --
# ----------------------------------

# Вещественные числа не точные!
0.1 + 0.2 == 0.3  # => False

# Для их сравнения, нужно учитывать погрешность:
x = 0.1 + 0.2
y = 0.3
epsilon = 10 ** -6  # Погрешность с точностью до 6 знаков после запятой
if abs(x - y) < epsilon:
    print('Equal')
else:
    print('Not equal')

# -----------------------------------
# -- Округление вещественных чисел --
# -----------------------------------

# int   - округляет в сторону нуля (отбрасывет дробную часть)
# round - округляет до ближайшего целого,
#         если дробная часть равна 0.5, то к чётному
# floor - округляет в меньшую сторону
# ceil  - округляет в большую сторону
# trunc - работает как int

# Функции floor, ceil и trunc находятся в библиотеке math
# Как ими воспользоваться? (Все импорты должны быть вверху файла)

# 1
import math

print(math.floor(-2.5))
print(math.ceil(-2.5))

# 2
from math import floor, ceil

print(floor(-2.5))
print(ceil(-2.5))


#            ---------------------            #
#            Логический тип данных            # 
#            ---------------------            #

# Тип переменной - bool
# Принимаемые значения: True и False

# ---------------------
# -- Знаки сравнения --
# ---------------------

#  <   - меньше
#  >   - больше
#  <=  - меньше либо равно
#  >=  - больше либо равно
#  !=  - не равно
#  ==  - равно (проверяет равенство двух значений)
#  is  - равно (проверяет, указывают ли объекты на одну и ту же область памяти)

a = [1, 2, 3]   # Объект список
b = [1, 2, 3]   # Другой объект, который указывает на другую область памяти
print(a == b)  # => True
print(a is b)  # => False
# Для экономии памяти, булевы типы, числа и строки могут кешироваться
# Тогда is вернет True, даже если переменные разные, но имеют одно значение

# В выражении можно использовать несколько знаков сравнения: x < y < z

# -------------------------
# -- Логические операции --
# -------------------------

# Имеют приоритет ниже, чем операции сравнения

#  and - и
#  or  - или
#  not - не

# -----------------------------------------
# -- Сравнение строк, кортежей и списков --
# -----------------------------------------

# Строки сравниваются в таком порядке:
# 1. Сравнивается посимвольно значение в кодировке Unicode. Регистр важен!
#   'a' < 'b';  'a' > 'A'
#   'abcd' < 'bc';   'aBc' > 'AbC'
# 2. Если строки имеют одинаковые подстроки в начале, сравнивается их длина:
#   'Orange' < 'Orange Juice'

# Для кортежей и списков все то же самое:
# (1, 2, 3, 4) < (2, 3, 4)
# [1, 2, 3] > [1, 2]

# При сравнении несравнимого будут ошибки:
(1, 2) < ("Some text", 42)    # Ошибка!
(1, 2) < (42, "Some text")    # True


#            -------            #
#            Кортежи            # 
#            -------            #

# Кортежи во многом действуют как строки: +, *, срезы, len()

a = (1, 2, 3)
b = (4, 5, 6)

# -- Кортеж из одного элемента (синглтон) --
c = (1)     # Это не кортеж! Это int
d = (1,)    # А это уже кортеж из одного элемента

# -----------------------------
# -- Арифметические операции --
# -----------------------------

# Работают, как со строками
a + b  # => (1, 2, 3, 4, 5, 6)
a * 3  # => (1, 2, 3, 1, 2, 3, 1, 2, 3)

# Важна правильная расстановка скобок
(1, 2) + (3, 4)  # => (1, 2, 3, 4)
1, 2 + 3, 4      # => (1, 5, 4)

# --------------------------
# -- Преобразование типов --
# --------------------------

# -- Преобразование строки в кортеж: tuple() --
string = '123'
my_tuple = tuple(string)  # => ('1', '2', '3')

# -- Преобразование кортежа в строку: str() --
my_tuple = (1, 2, 3)
string = str(my_tuple)  # => '(1, 2, 3)'

# --------------------------------
# -- Доступ к элементам кортежа --
# --------------------------------

my_tuple = (('a', 1, 3.14), 'abc', ((1), (2, )))
my_tuple[0]   # ('a', 1, 3.14)
my_tuple[1]   # 'abc'
my_tuple[2]   # ((1), (2, )) - кортеж состоящий из числа 1 и синглтона (2, )
my_tuple[2][1]   # (2,)
my_tuple[2][1][0]   # 2

# -----------
# -- Срезы --
# -----------

my_tuple = (1, 2, 3)

# Если в срезе более одного параметра, то будет формироваться кортеж (даже если это синглтон)
my_tuple[1:]    # (2, 3)
my_tuple[2]     # 3
my_tuple[2:]    # (3,)

# -----------------------------------
# -- Распаковка и упаковка кортежа --
# -----------------------------------

manDesc = ("Ivan", "Ivanov", 28)
name, surname, age = manDesc
# Теперь в переменных лежат значения: name = "Ivan", surname = "Ivanov", age = 28

a, b, c = 1, 2, 3
a, b, c = c, b, a
print(a, b, c)   # => 3, 2, 1
# Это не эквивалетно записи a = c; b = b; c = a. Тут результат - 3, 2, 3


#            ------            #
#            Списки            # 
#            ------            #

# Список это аналог массивов в других ЯП. 
# Во многом они похожи на кортежи; к ним применимы len(), срезы
# Отличие в том, что они изменяемы

myList = [1, 2, 3]
myList[1] = 4
print(myList)   # => [1, 4, 3]

# -----------------------
# -- Изменение списков --
# -----------------------

# Список является ссылкой

a = [1, 2]  # a - это ссылка на объект со значением [1, 2]
b = a       # b - это новая ссылка на `тот же` объект
b[0] = 3    # При изменении значения объекта, значение по любой ссылке изменится
print(a)    # => [3, 2]
print(b)    # => [3, 2]

a = [1, 2]  # a - ссылка на `один` объект со значением [1, 2]
b = [1, 2]  # b - ссылка на `другой` объект со значением [1, 2]
a[0] = 3    # Объект по ссылке a теперь равен [3, 2]
print(b)    # => [1, 2]. Объект по ссылке b не изменился, это другой объект

a = [1, 2]
b = a
a = [3, 4]  # Привязали другой объект. Теперь у a и b ссылки на разные объекты
print(b)    # => [1, 2]

# ----------------------------------------------------
# -- Передача списка в функцию в качестве параметра --
# ----------------------------------------------------

# В функцию список передается тоже ссылкой.
# Следовательно функция может изменить значения внутри списка:

def replaceFirst(myList):
    myList[0] = 'x'

nowList = list('abcdef')
replaceFirst(nowList)   # => ['x', 'b', 'c', 'd', 'e', 'f']
print(nowList)

# Саму ссылку функция изменить не сможет:

def reverseList(funcList):
    funcList = funcList[::-1]   # Операция среза создает новый объект

mainList = list('abc')
reverseList(mainList)   # => ['a', 'b', 'c']. Список не изменился
print(mainList)

# --------------------------
# -- Преобразование типов --
# --------------------------

# -- Преобразование в список: list() --
my_tuple = (1, 2, 3)
my_list = list(my_tuple)   # => [1, 2, 3]

my_string = '123'
my_list = list(my_string)  # => ['1', '2', '3']

# -- Преобразование из списка --
my_list = [1, 2, 3]
my_tuple = tuple(my_list)  # => (1, 2, 3)
my_string = str(my_list)   # => '[1, 2, 3]'

# ------------------------
# -- Сортировка списков --
# ------------------------

# -- Метод .sort() --

# Изменяет исходный список.
# Принимает на вход только список
my_list = [1, 4, 2, 3]
my_list.sort()  # => [1, 2, 3, 4]

# -- Функция sorted() --

# Не изменяет исходный список.
# Принимает на вход любой итерируемый объект. Возвращает список
my_list = [1, 4, 2, 3]
sorted_list = sorted(my_list)  # => [1, 2, 3, 4]

# -- Сортировка по невозрастанию (убыванию) --
my_list.sort(reverse=True)
sorted_list = sorted(my_list, reverse=True)

# -- Параметр key в функции sort() --

# Ключ (key) - это функция, которая применяется к каждому элементу списка,
#   а потом сравнение элементов происходит по значению этой функции

strings = ['c', 'abb', 'b']
print(sorted(strings, key=len))  # => ['c', 'b', 'abb']
# Т.е. сортировка произошла по длине.
# При этом строки одинаковой длины сохранили свой порядок


# ---------------------
# -- Полезные методы --
# ---------------------

# -- Не изменяющие список и возвращающие значение --

# count(x) - подсчитывает число вхождений значения x в список. O(N)
# index(x) - находит позицию первого вхождения значения x в список. O(N)
# index(x, from) - находит позицию первого вхождения значения x в список,
#   начиная с позиции from. O(N)

# -- Изменяющие список и не возвращающие значение --

# append(x) - добавляет значение x в конец списка
# extend(otherList) - добавляет все содержимое списка otherList в конец списка.
#   В отличие от операции + изменяет объект, к которому применен, а не создает новый
# remove(x) - удаляет первое вхождение числа x в список. O(N)
# insert(index, x) - вставляет число x в список так, что оно оказывается на позиции index.
#   Число, стоявшее на позиции index и все числа правее него сдвигаются на один вправо. O(N)
# reverse() - Разворачивает список. O(n)
#   Меняет значение по ссылке, а не создает новый список как myList[::-1]

# -- Изменяющие список и возвращающие значение --

# pop() - возвращает последний элемент списка и удаляет его
# pop(index) - возвращает элемент списка на позиции index и удаляет его. O(N)


#            --------------------------            #
#            Явное преобразование типов            # 
#            --------------------------            #

# Python - язык со строгой типизацией, в отличие от PHP или JavaScript

# ------------------------------------------
# -- int() - преобразование в целое число --
# ------------------------------------------

# -- Строки --
converted_value = int('10')    # => 10
converted_value = int('')      # => Ошибка ValueError
converted_value = int('Text')  # => Ошибка ValueError

# -- Булевые переменные --
converted_value = int(False)   # => 0
converted_value = int(True)    # => 1

# -- Вещественные числа --
converted_value = int(3.61)     # => 3

# -------------------------------------
# -- str() - преобразование в строку --
# -------------------------------------

value = str(10)    # '10'
value = str(10.1)  # '10.1'
value = str(True)  # 'True'
value = str()      # ''

# ---------------------------------------------------
# -- float() - преобразование в вещественное число --
# ---------------------------------------------------

value = float(5)   # 5.0

# В операциях с float, все int неявно преобразуются в float
value = 3 + 1.2    # 4.2 (неявно выполняется код float(3) + 1.2)


#            ---------            #
#            Пременные            # 
#            ---------            #

euros_count = 100
dollars = euros_count * 1.25
a, b, c = 1, 2, 3

# ---------------------------------
# -- Определение типа переменной --
# ---------------------------------

a = 1
b = '123'
c = (1, (2, 3), 4)
type(a)  # => <class 'int'>
type(b)  # => <class 'str'>
type(c)  # => <class 'tuple'>

# ---------------------------
# -- Именование переменных --
# ---------------------------

# kebab-case — составные части переменной разделяются дефисом (my-super-var)
# snake_case — для разделения используется подчеркивание (my_super_var)
# CamelCase — каждое слово в переменной пишется с заглавной буквы (MySuperVar)
# В Python используется snake_case

# ---------------------------------------
# -- Локальные и глобальные переменные --
# ---------------------------------------

# Использование глобальных переменных внутри функций - очень плохой тон!

# -- Глобальные переменные видны внутри функций --
def f():
    print(a)
a = 1   # Глобальная
f()     # => 1 (Никакой ошибки)

# -- Переменные, определенные внутри функций, считаются локальными --
def f():
    a = 1   # Локальная
f()         # => 1
print(a)    # => NameError: name 'a' is not defined

# -- Локальные переменные можно называть так же, как глобальные --
def f():
    a = 1   # Локальная
    print(a)
a = 0       # Глобальная
f()         # => 1
print(a)    # => 0

# Даже если присваивание никогда не выполнится, переменная будет локальной
def f():
    print(a)
    if False:
        a = 0  # Локальная
a = 1   # Глобальная
f()     # => UnboundLocalError: local variable 'a' referenced before assignment

# -- Принудительное указание глобальной переменной --
def f():
    global a    # Указание, что функция может менять глобальную переменную a
    a = 1   # Глобальная
    print(a, end=' ')
a = 0       # Глобальная
print(a)    # => 0
f()         # => 1
print(a)    # => 1

# --------------
# -- Костанты --
# --------------

# Те же переменные, но пишутся заглавными буквами (и, увы, их можно поменять)
PI = 3.14


# - - - - - - - - - - - Операторы и циклы - - - - - - - - - - - #

#            ------------------------------            #
#            Условный оператор: if ... else            # 
#            ------------------------------            #

# Обязательно соблюдать отступ в 4 пробела или один tab.
# Блок else необязателен

x = int(input())
if x >= 0:
    print(x)
else:
    print(-x)

# ---------------------------------
# -- Вложенный условный оператор --
# ---------------------------------

eyes = int(input())
legs = int(input())
if eyes >= 8:
    if legs == 8:
        print("spider")
    else:
        print("scallop")
else:
    if legs == 6:
        print("bug")
    else:
        print("cat")

# -------------------------------
# -- Конструкция "иначе-если" --
# --   if ... elif ... else   --
# -------------------------------

number = int(input())
if number == 1:
    print('One')
elif number == 2:
    print('Two')
else:
    print('Other')


#            -----------            #
#            Цикл: while            # 
#            -----------            #

# Например, выведем все числа по возрастанию от 1 до N:
n = int(input())
i = 1
while i <= n:
    print(i)
    i = i + 1

# Или найдем минимум в последовательности (оканчивается на 0):
now = int(input())
nowMin = now
while now != 0:
    if now < nowMin:
        nowMin = now
    now = int(input())
print(nowMin)

# -- Оператор остановки: break --

# После выполнения break работа цикла прекращается

i = 1
while True:
    print(i)
    i = i + 1
    if i > 100:
        break

# В Python к циклу while можно написать блок else.
# Команды в этом блоке будут выполняться, если цикл завершил свою работу
#   нормальным образом (т.е. условие в какой-то момент перестало быть истинным)
# и не будут выполняться только в случае,
#   если выход из цикла произошел с помощью команды break.

# -- Оператор продолжения: continue --

# Оператор continue начинает исполнение тела цикла заново, начиная с проверки условия

# Например, дана последовательность чисел. Вывести все положительные числа
now = -1
while now != 0:
    now = int(input())
    if now <= 0:
        continue
    print(now)


#            ---------            #
#            Цикл: for            # 
#            ---------            #

# -------------------
# -- Функция range --
# -------------------

# Функция range генерирует объекты типа iterable, состоящие из целых чисел.

# -- range(n) --
# Генерирует iterable, содержащий последовательные числа от 0 до n-1.
print(tuple(range(10)))  # => (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)

# -- range(from, to) --
# Генерирует iterable со всеми числами от from до to-1 включительно.
range(4, 10)      # => 4, 5, 6, 7, 8, 9

# -- range(from, to, step) --
# Генерирует iterable с числами от from, не превышающие to с шагом изменения step. 
# Если шаг отрицателен, то from должен быть больше to.
range(4, 10, 3)   # => 4, 7
range(10, 0, -2)  # => 10, 8, 6, 4, 2

# ---------------
# -- Цикл: for --
# ---------------

# Цикл for перебирает элементы tuple или iterable

for color in ('red', 'green', 'yellow'):
    print(color, 'apple')
# red apple  
# green apple
# yellow apple

for i in range(1, 100, 2):
    print(i)
# Напечатает нечетные числа от 1 до 99 в столбик

for i in range(1, 11):
    for j in range(1, 11):
        print(i * j, end=' ')
    print()
# Напечатает таблицу умножения


#            -------            #
#            Функции            # 
#            -------            #

# ------------------------
# -- Встроенные функции --
# ------------------------

# -- Есть стандартная библиотека, и в ней есть тысячи функций --
# Справочник встроенных функций: https://docs-python.ru/standart-library/

# -- Есть функции, а есть методы --
# Метод - это действие над объектом, и вызывается через точку
name = 'Python'
print(name)     # Функция
name.lower()    # Метод

# -- Некоторые методы дублируют функции (или наоборот) --
# Такие методы, которые не предназначены для прямого вызова, обернуты в __
x = -5
abs(x)          # вызывает x.__abs__() - модуль числа x
pow(x, 3)       # вызывает x.__pow__(3) - x в степени 3
len('Hexlet')   # вызывает 'Hexlet'.__len__() - длина строки

# -- map() --

# Эта функция принимает два параметра: функцию и итерируемый объект (список, строка и т.д)
# Возвращает объект iterable, где каждый элемент объекта был подвергнут функции
# Важно не забывать потом перевести этот iterable в нужный нам тип - список, кортеж и пр.

ls = [1, 2, 3, 4, 5, 6, 7, 8, 9]

def my_funс(x):
    return x*2

r = map(my_funс, ls)
print(r)        # => ... Тут только ссылка, вычислений еще не произошло
print(list(r))  # => [2, 4, 6, 8, 10, 12, 14, 16, 18]

# В том числе, в нее можно передавать лямбда-функции
list(map(lambda x: x * x, ls))  # => [1, 4, 9, 16, 25, 36, 49, 64, 81]

# ----------------------------------
# -- Создание собственных функций --
# ----------------------------------

# -- Определение функции --

# Описание функции может быть где угодно в коде, раньше первого ее вызова.
# Перед функцией и после должно быть две строки (так требует flake8), я это тут пропускаю
# Некоторым параметрам можно передать значение по умолчанию (=...),
#   такие параметры должны идти в самом конце списка параметров.

def my_function(x, y, a=5, b=10, c=100):
    # Внутри тела отступ четыре пробела или одна табуляция
    sum = x + y
    info = f'Сумма = {sum}. Параметры: а = {a}, b = {b}, c = {c}'
    return info

print(my_function(1, 2))  # Вызов ранее определенной функции

# -- Возврат нескольких значений функцией (кортеж) --

def sort2(a, b):
    if a < b:
        return a, b
    else:
        return b, a

min, max = sort2(3, 2)
print(min, max)

# -- Рекурсивная функция --

def factorial(n):
    if n == 0:
        return 1
    return n * factorial(n - 1)

print(factorial(10))

# -- Минимальное определение функции --
# Еесли функция пустая, пишем внутри pass

def noop():
    pass

# --------------------
# -- Лямбда-функции --
# --------------------

# Простая функция, которая используется сразу в месте создания и не имеет имени.

# Функция, возводящая число в квадрат:
def sqr(x):
    return x**2

# Аналогичная лямбда-функция:
lambda x: x**2

# -- Обычно лямбда-функции передаются в качестве параметра --
# Например, в функцию map()
print(' '.join(map(lambda x: str(x**2), range(1, 101))))  # Квадраты чисел от 1 до 100

# -- Можно создать ссылку на объект типа функция --
# Получится что-то вроде названия функции. Лучше тогда уж использовать def
lambdaSqr = lambda x: x**2
print(lambdaSqr(3))

# -------------------------------------
# --     Именованные параметры и     --
# -- неопределенное число параметров --
# -------------------------------------

# Именованные параметры - это параметры со значениями по умолчанию (=...)
# Просто их можно передавать с именем, а можно без (если такой параметр один)

def printList(myList, sep=' ', info=''):
    print(sep.join(map(str, myList)))
    print(info)

printList([1, 2, 3])            # 1 2 3
printList([3, 2, 1], sep='\n')  # В столбик 3 2 1
printList([1, 2], ' + ')        # 1 + 2
printList([5, 6], info='info')  # 5 6 на следующей строчке 'info'

# Неопределенное число параметров пишется через звездочку *args
# В этом случае *args автоматически будет упаковано в список

def mySum(*args):
    nowSum = 0
    for now in args:
        nowSum += now
    return nowSum

print(mySum(1, 2))
print(mySum(1, 2, 3, 4))

# Можно указывать и другие обязательные параметры,
#   но параметр со звездочкой всегда должен быть последним
# Если есть именованные параметры, они идут после параметра со звездочкой

def myMin(first, *others):
    nowMin = first
    for now in others:
        if now < nowMin:
            nowMin = now
    return nowMin

print(myMin(1))
print(myMin(3, 1, 2))

# Итак, сначала обычные параметры, потом со звездочкой, потом именованные

#            -------            #
#            Объекты            # 
#            -------            #

# У объектов есть атрибуты и методы

# ------------------------
# -- Встроенные объекты --
# ------------------------

# Например, строка - это объект в Python.

# -- Методы --

first_name = '  Grigor   \n'
print(first_name.strip())  # 'Grigor'

# Примитивные методы не меняют само содержимое переменной
name = 'Tirion'
print(name.upper())  # => TIRION
print(name)  # => Tirion

# -- Атрибуты --

# Например, артибут, возвращающий документацию функции:
len.__doc__  # 'Return the number of items in a container.'

# Атрибуты работают и выглядят как переменные,
# только указываются через точку после объекта.
