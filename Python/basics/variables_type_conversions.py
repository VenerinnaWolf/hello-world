# Переменные, типы, преобразование типов, аннотации типов

#            -----------            #
#            Типы данных            #
#            -----------            #

# Неизменяемые: bool, int, float, str, tuple (кортеж), frozenset (неизменяемая версия set)
# Изменяемые: list (список), set (множество), dict (словарь), большинство самописных классов
# None - аналогия null из других языков программирования.


#            ----------            #
#            Переменные            #
#            ----------            #

euros_count = 100
dollars = euros_count * 1.25
a, b, c = 1, 2, 3

# ---------------------------------
# -- Определение типа переменной --
# ---------------------------------

a = 1
b = '123'
c = (1, (2, 3), 4)
type(a)  # => <class 'int'>
type(b)  # => <class 'str'>
type(c)  # => <class 'tuple'>

# ---------------------------
# -- Именование переменных --
# ---------------------------

# kebab-case — составные части переменной разделяются дефисом (my-super-var)
# snake_case — для разделения используется подчеркивание (my_super_var)
# CamelCase — каждое слово в переменной пишется с заглавной буквы (MySuperVar)
# В Python используется snake_case

# ---------------------------------------
# -- Локальные и глобальные переменные --
# ---------------------------------------

# Использование глобальных переменных внутри функций - очень плохой тон!

# 1. *Глобальные* переменные видны внутри функций
def f():
    print(a)
a = 1   # Глобальная
f()     # => 1 (Никакой ошибки)

# 2. Переменные, определенные внутри функций, считаются *локальными*
def f():
    a = 1   # Локальная
f()         # => 1
print(a)    # => NameError: name 'a' is not defined

# 3. Локальные переменные можно называть так же, как глобальные
def f():
    a = 1   # Локальная
    print(a)
a = 0       # Глобальная
f()         # => 1
print(a)    # => 0

# Даже если присваивание никогда не выполнится, переменная будет локальной
def f():
    print(a)
    if False:
        a = 0  # Локальная
a = 1   # Глобальная
f()     # => UnboundLocalError: local variable 'a' referenced before assignment

# 4. Принудительное указание глобальной переменной
def f():
    global a    # Указание, что функция может менять глобальную переменную a
    a = 1   # Глобальная
    print(a, end=' ')
a = 0       # Глобальная
print(a)    # => 0
f()         # => 1
print(a)    # => 1

# ---------------
# -- Константы --
# ---------------

# Те же переменные, но пишутся заглавными буквами (и, увы, их можно поменять)
PI = 3.14


#            --------------------------            #
#            Явное преобразование типов            #
#            --------------------------            #

# Python - язык со строгой типизацией, в отличие от PHP или JavaScript

# ------------------------------------------
# -- int() - преобразование в целое число --
# ------------------------------------------

# -- Строки --
converted_value = int('10')    # => 10
converted_value = int('')      # => Ошибка ValueError
converted_value = int('Text')  # => Ошибка ValueError

# -- Булевые переменные --
converted_value = int(False)   # => 0
converted_value = int(True)    # => 1

# -- Вещественные числа --
converted_value = int(3.61)     # => 3

# -------------------------------------
# -- str() - преобразование в строку --
# -------------------------------------

value = str(10)    # '10'
value = str(10.1)  # '10.1'
value = str(True)  # 'True'
value = str()      # ''

# ---------------------------------------------------
# -- float() - преобразование в вещественное число --
# ---------------------------------------------------

value = float(5)   # 5.0

# В операциях с float, все int неявно преобразуются в float
value = 3 + 1.2    # 4.2 (неявно выполняется код float(3) + 1.2)


#            ---------------            #
#            Аннотации типов            #
#            ---------------            #

# Позволяют указать явно тип переменной (с python 3.5)
name: str = 'Tommy'
age: int = 24
title: str

# Можно указать несколько типов через черту:
items: tuple | list

# -----------------------
# -- Аннотация функций --
# -----------------------

# Параметры функции аннотируются так же как переменные,
# Возвращаемое значение указывается после стрелки -> и до завершающего двоеточия
def celcius_to_fahrenheit(celcius_temp: float) -> float:
    return (celcius_temp * 9/5) + 32

# Если функция ничего не возвращает, то можно написать -> None

# ----------------------
# -- Специальные типы --
# ----------------------

# Для их использования, нужно подключить модуль typing:
from typing import Any, Optional, Union, Literal, List, Tuple, Dict

# 1. Optional - позволяет использовать вместе с определенным типом тип None:
amount: int = None           # Incompatible types in assignment (expression has type "None", variable has type "int")
price: Optional[int] = None  # никакой ошибки

# 2. Any - любой тип:
result: Any = "SUCCESS"
result = 10

# 3. Union - позволяет использовать несколько перечисленных типов.
# Аннотация Optional[T] эквивалентна Union[T, None]
x: Union[int, float]

# 4. Literal - значение, которое имеет переменная или функция, равно одному из указанных значений.
GENDER = Literal["male", "female", "non–conforming"]

# 5. Списки - позволяет конкретизировать, какие элементы можно передавать в список (находится в typing.List).
# Можно использовать все слова выше. Если тип элемента не указан, предполагается, что это Any.
titles: List[str] = ["hello", "world"]
items: List = ["hello", 1]
# Аналогичные аннотации есть для множеств: typing.Set и typing.FrozenSet

# 6. Кортежи - в квадратных скобках указывается тип каждого элемента кортежа по отдельности.
# Если планируется хранить неизвестное количество однотипных элементов, можно воспользоваться многоточием (...).
price_container: Tuple[int] = (1,)  # создать кортеж с двумя полями будет нельзя
price_container = (1, 2)  # Incompatible types in assignment (expression has type "Tuple[int, int]", variable has type "Tuple[int]")
price_with_title: Tuple[int, str] = (1, "hello")
prices: Tuple[int, ...] = (1, 2)
something: Tuple = (1, 2, "hello")

# 7. Словари - Для словарей используется typing.Dict. Отдельно аннотируется тип ключа и тип значений:
book_authors: Dict[str, str] = {"Fahrenheit 451": "Bradbury"}
